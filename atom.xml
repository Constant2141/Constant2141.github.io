<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星辰在上</title>
  
  <subtitle>万物皆虚，万物皆允</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-21T03:25:18.767Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郑庆义</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>css3动画三属性</title>
    <link href="http://yoursite.com/2018/10/21/css3%E5%8A%A8%E7%94%BB%E4%B8%89%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2018/10/21/css3动画三属性/</id>
    <published>2018-10-21T03:21:49.000Z</published>
    <updated>2018-10-21T03:25:18.767Z</updated>
    
    <content type="html"><![CDATA[<p>把css3里与动画有关的三个常见属性归纳到一起<br><a id="more"></a></p><h2 id="CSS3制作动画的几个属性：变形-transform-、转换-transition-和动画-animation"><a href="#CSS3制作动画的几个属性：变形-transform-、转换-transition-和动画-animation" class="headerlink" title="CSS3制作动画的几个属性：变形(transform)、转换(transition)和动画(animation)"></a>CSS3制作动画的几个属性：变形(transform)、转换(transition)和动画(animation)</h2><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>transition主要包含四个属性值：<br>1、执行变换的属性：transition-property<br>2、变换延续的时间：transition-duration<br>3、延续时间内变换的速率：transition-timing-function<br>4、变换延迟时间：transition-delay.</p><h4 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h4><p>指定当元素其中一个属性改变时执行transition效果，其主要有以下几个值：none(没有属性改变)；all（所有属性改变）这个也是其默认值；indent（元素属性名）</p><h4 id="transition-duration"><a href="#transition-duration" class="headerlink" title="transition=duration"></a>transition=duration</h4><p>默认值0，也就是即时。设一个延续时间单位s或者ms</p><h4 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h4><p>ease 逐渐变慢<br>linear 匀速<br>ease-in 加速<br>ease-out 减速<br>ease-in-out 先加速后减速<br>cubic-bezier 自定义时间曲线</p><h4 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h4><p>默认值0，也就是即时。设一个延迟时间单位s或者ms</p><p>随便一个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  -moz-transition: all <span class="number">0.5</span>s ease-<span class="keyword">in</span>;</span><br><span class="line">  -webkit-transition: all <span class="number">0.5</span>s ease-<span class="keyword">in</span>;</span><br><span class="line">  -o-transition: all <span class="number">0.5</span>s ease-<span class="keyword">in</span>;</span><br><span class="line">  transition: all <span class="number">0.5</span>s ease-<span class="keyword">in</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>主要包括以下几种：旋转rotate、移动translate、扭曲skew、缩放scale以及矩阵变形matrix<br>有一点要注意的 在这里叠加多个属性是用空格分开而不是逗号</p><p>通过指定的角度参数进行2D旋转，设置的是正数为顺时针旋转，负的为逆时针旋转，例如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transform:rotate(<span class="number">30</span>deg)</span><br><span class="line">transform:translateX(<span class="number">100</span>px):</span><br><span class="line">transform:skew(<span class="number">30</span>deg,<span class="number">10</span>deg):</span><br><span class="line">transform:scale(<span class="number">2</span>,<span class="number">1.5</span>):</span><br></pre></td></tr></table></figure></p><h3 id="animate"><a href="#animate" class="headerlink" title="animate"></a>animate</h3><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">说明</th><th style="text-align:left">随便备注</th></tr></thead><tbody><tr><td style="text-align:left">animation-name</td><td style="text-align:left">指定@keyframes的名字</td></tr><tr><td style="text-align:left">animation-duration</td><td style="text-align:left">动画指定需要多少秒或毫秒完成</td><td style="text-align:left">0表示无动画，单位可以设s秒或ms毫秒</td></tr><tr><td style="text-align:left">animation-timing-function</td><td style="text-align:left">规定动画的速度曲线</td><td style="text-align:left">ease-in-out、linear等</td></tr><tr><td style="text-align:left">animation-delay</td><td style="text-align:left">规定在动画开始之前的延迟。</td><td style="text-align:left">默认值是0，立即播放动画，设负值表示跳过-2s</td></tr><tr><td style="text-align:left">animation-iteration-count</td><td style="text-align:left">定义动画的播放次数。</td><td style="text-align:left">默认是1，可以设置无限循环infinite</td></tr><tr><td style="text-align:left">animation-direction</td><td style="text-align:left">动画播放的方向</td><td style="text-align:left">normal正常播放，alternate正方向轮转，alternate-reverse与前者相反</td></tr><tr><td style="text-align:left">animation-play-state</td><td style="text-align:left">动画的状态</td><td style="text-align:left">可以设running正在播放,pause暂停动画，通常在JS使用该属性object.style.animationPlayState=”paused”来暂停动画。</td></tr><tr><td style="text-align:left">animation-fill-mode</td><td style="text-align:left">动画时间外属性</td><td style="text-align:left">可设none，forwards，backwards，both，默认值none表示动画播完后，恢复到初始状态，forwards当动画播完后，保持@keyframes里最后一帧的属性。backwards表示开始播动画前(也就是delay时间内)，应用@keyframes里第一帧的属性，both表示forwards和backforwards都应用。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;把css3里与动画有关的三个常见属性归纳到一起&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>10_14笔记</title>
    <link href="http://yoursite.com/2018/10/14/10-14%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/14/10-14笔记/</id>
    <published>2018-10-14T03:27:26.000Z</published>
    <updated>2018-10-21T04:18:51.457Z</updated>
    
    <content type="html"><![CDATA[<p>行级元素只能嵌套行级，块级可以嵌套任何，但是有特殊的↓<br>p标签是块级的，但是嵌套了div进去后，p会被切成两半<br>a标签不能嵌套a标签</p><p>设了absolute和float后 内部元素会变成inline-block（和手动设置display:inline-block再可以对行级元素设宽高一样</p><p>文本类元素一旦里面有了文字，外部文字就会和里面的对齐</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;行级元素只能嵌套行级，块级可以嵌套任何，但是有特殊的↓&lt;br&gt;p标签是块级的，但是嵌套了div进去后，p会被切成两半&lt;br&gt;a标签不能嵌套a标签&lt;/p&gt;
&lt;p&gt;设了absolute和float后 内部元素会变成inline-block（和手动设置display:inline
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>10_13笔记</title>
    <link href="http://yoursite.com/2018/10/13/10-13%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/13/10-13笔记/</id>
    <published>2018-10-13T03:27:20.000Z</published>
    <updated>2018-10-21T04:17:19.228Z</updated>
    
    <content type="html"><![CDATA[<p>单行文本 height和line-height设为一个值实现单行文本居中</p><p>文本溢出处理三件套<br>white-space:nowrap;文本溢出不换行<br>overflow:hidden;<br>text-overflow:ellipsis;//省略号</p><p>多行文本溢出处理，PC端没有很好的解决方法，手动打点，截断overflow：hidden</p><p>使用css添加图片时，如果网络不佳，为了应对浏览器默认加载策略(在网速不好的时候会不加载CSS JS)，这个时候采取两种方法</p><p>1、text-indent一定距离让文字跟在图片后，white-space:nowrap,overflow:hidden<br>2、取消图片的height 用padding-top代替 用padding撑开div，再设overflow:hidden</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单行文本 height和line-height设为一个值实现单行文本居中&lt;/p&gt;
&lt;p&gt;文本溢出处理三件套&lt;br&gt;white-space:nowrap;文本溢出不换行&lt;br&gt;overflow:hidden;&lt;br&gt;text-overflow:ellipsis;//省略号&lt;/
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>10_12笔记</title>
    <link href="http://yoursite.com/2018/10/12/10-12%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/10/12/10-12笔记/</id>
    <published>2018-10-12T03:27:35.000Z</published>
    <updated>2018-10-21T04:24:01.364Z</updated>
    
    <content type="html"><![CDATA[<p>text-indent : 2em;  首行缩进</p><p>1em=1*font-size </p><p>块级元素独占一行 可以用css改变宽高 而行级元素不能，img是行级块元素 </p><p>初始化ul标签  list-style: none  margin:0  padding:0</p><p>body 天生默认 margin:8px </p><p>定位复习<br>display:absolute  脱离原来位置进行定位，找最近的有定位的父级，没有则相对文档<br>display:relative  保留原来位置进行定位，相对于自己原来的位置定位<br>一般用relative作参照物 用absolute定位</p><p>垂直方向的margin父子嵌套（兄弟结构也会） 取最大的值 这个bug叫做margin塌陷<br>解决方法两个<br>1暴力解法 在父级加一个 border-top:1px solid<br>2使用bfc  但是只是弥补 目前没有一个完美解决的方法</p><p>那么如何触发一个盒子的bfc (block format Context),四种方法<br>position:absolute<br>display:inline-block<br>float:left||right<br>overflow: hidden</p><p>浮动元素产生浮动流，块级元素看不到浮动元素，只有产生了bfc的元素或文本可以看到<br>要取消浮动可以用 伪元素(伪元素天生是行级元素)或bfc</p><p>1可以用伪元素清楚浮动 xx::after{<br>    content:””;<br>    display:block;<br>    clear:both;<br>}<br>2触发bfc<br>原理就是 设了absolute和float后 内部元素会变成inline-block</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;text-indent : 2em;  首行缩进&lt;/p&gt;
&lt;p&gt;1em=1*font-size &lt;/p&gt;
&lt;p&gt;块级元素独占一行 可以用css改变宽高 而行级元素不能，img是行级块元素 &lt;/p&gt;
&lt;p&gt;初始化ul标签  list-style: none  margin:0
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>近期一句话总结</title>
    <link href="http://yoursite.com/2018/09/23/%E8%BF%91%E6%9C%9F%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/23/近期一句话总结/</id>
    <published>2018-09-23T02:45:50.000Z</published>
    <updated>2018-09-23T03:11:12.759Z</updated>
    
    <content type="html"><![CDATA[<p>·git checkout practice：新世界是暑期前做的，开学后又进行了细节的修改，因为是第一次做页面，学到的东西还是非常多。之后做了一个打字机小游戏和一个简单的主要利用定时器和工厂实现的动画。<br>·git checkout DOM:日常被各种事情卡住，只有在文学课上才是最专心的。</p><p>·git checkout other：其他一些东西，如每天的网课和英语课。</p><p>·git checkout node：node还是继续之前那些视频资源，群里偶尔也有新暂时没有精力</p><p>·git checkout affair：弄来了两个“优秀的”源码来学习，看看能不能学到啥把阿肥魔改，真的是一堆不成熟的想法+不成熟的技法导致很多问题，9月22日前端们终于突然想起要继续对接了，所以中秋假期又双叒叕还是自己忙前忙后。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;·git checkout practice：新世界是暑期前做的，开学后又进行了细节的修改，因为是第一次做页面，学到的东西还是非常多。之后做了一个打字机小游戏和一个简单的主要利用定时器和工厂实现的动画。&lt;br&gt;·git checkout DOM:日常被各种事情卡住，只有在文
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>nodemailer使用回顾</title>
    <link href="http://yoursite.com/2018/09/17/nodemailer%E4%BD%BF%E7%94%A8%E5%9B%9E%E9%A1%BE/"/>
    <id>http://yoursite.com/2018/09/17/nodemailer使用回顾/</id>
    <published>2018-09-17T14:28:58.000Z</published>
    <updated>2018-09-17T14:56:21.599Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transporter=nodemailer.createTransport(&#123;<span class="comment">//设置邮件传输</span></span><br><span class="line">   <span class="comment">// service: 'qq', service和host二选一，写法不同</span></span><br><span class="line">    host:<span class="string">"smtp.qq.com"</span>, <span class="comment">//设置服务，可以换成smtp.163.com</span></span><br><span class="line">    secureConnection:<span class="literal">true</span>, <span class="comment">//是否使用TLS，如果是true端口为465，否则为其他端口或者568</span></span><br><span class="line">    port:<span class="number">465</span>,          <span class="comment">//SMTP端口</span></span><br><span class="line">    auth:&#123; </span><br><span class="line">        user:<span class="string">"706608189@qq.com"</span>, <span class="comment">//发送人邮箱 </span></span><br><span class="line">        pass:<span class="string">"czvbqzqdnbywbfdd"</span><span class="comment">//我的授权码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendEmail = <span class="function"><span class="keyword">function</span>(<span class="params">mail,msg,cb</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> mailOption=&#123;</span><br><span class="line">        <span class="keyword">from</span>:<span class="string">"xxxxxx@qq.com"</span>,<span class="comment">//发件人邮箱</span></span><br><span class="line">        to:mail<span class="comment">//收件人邮箱，例如req.body.email,</span></span><br><span class="line">        subject:<span class="string">"注册校验码"</span><span class="comment">//邮件标题</span></span><br><span class="line">        html: <span class="string">'msg'</span><span class="comment">//邮件内容</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  transporter.sendMail(mailOption,<span class="function"><span class="keyword">function</span>(<span class="params">error,info</span>)</span>&#123;</span><br><span class="line">        cb(error,info); </span><br><span class="line">        <span class="comment">// if(error)&#123;</span></span><br><span class="line">        <span class="comment">//     res.json(&#123;code:400&#125;) ;//发送未成功</span></span><br><span class="line">        <span class="comment">//     return console.info(error);</span></span><br><span class="line">        <span class="comment">// &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//     res.json(&#123;code:200&#125;) ;//发送成功</span></span><br><span class="line">        <span class="comment">//     console.info("Message send");</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    sendEmail:sendEmail</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>pscp操作方法概括</title>
    <link href="http://yoursite.com/2018/09/17/pscp%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E6%A6%82%E6%8B%AC/"/>
    <id>http://yoursite.com/2018/09/17/pscp操作方法概括/</id>
    <published>2018-09-17T07:24:10.000Z</published>
    <updated>2018-09-17T07:34:51.403Z</updated>
    
    <content type="html"><![CDATA[<p>虽然是很早以前就掌握的东西了，但是一直懒得整理<br>————————————————————————————</p><h3 id="linux-删除命令"><a href="#linux-删除命令" class="headerlink" title="linux 删除命令"></a>linux 删除命令</h3><p>删除常用操作 rm -rf 目录名字<br>   -r 向下递归，不管有多少级目录，一并删除<br>    -f 直接强行删除，没有任何提示</p><p>注意：使用 rm -rf 的时候一定要小心，Linux没有回收站。</p><h3 id="Linux创建命令"><a href="#Linux创建命令" class="headerlink" title="Linux创建命令"></a>Linux创建命令</h3><p>touch Xxx 创建文件<br>mkdir xxx创建文件夹目录</p><h3 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h3><p>经过试验<br>如果是删除一个文件 重新上传文件夹后 ECS端的文件还在<br>如果是修改一个文件 重新上传文件夹后 ECS端的文件也会跟着修改 主要是看文件和文件夹的名字</p><p>我自己的ECS的MongoDB 所在地 /usr/local/mongodb/bin</p><h3 id="PSCP"><a href="#PSCP" class="headerlink" title="PSCP"></a>PSCP</h3><p>我自己的例子<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pscp <span class="symbol">D:</span>gitbook root<span class="variable">@47</span>.<span class="number">106.21</span>.<span class="number">195</span><span class="symbol">:/home/wwwroot/default/gitbook</span></span><br><span class="line"></span><br><span class="line">pscp -r <span class="symbol">d:</span>aaa root<span class="variable">@47</span>.<span class="number">106.21</span>.<span class="number">195</span><span class="symbol">:/home</span></span><br></pre></td></tr></table></figure></p><blockquote><p>　-p 拷贝文件的时候保留源文件建立的时间。<br>　　-q 执行文件拷贝时，不显示任何提示消息。<br>　　-r 拷贝整个目录<br>　　-v 拷贝文件时，显示提示信息。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然是很早以前就掌握的东西了，但是一直懒得整理&lt;br&gt;————————————————————————————&lt;/p&gt;
&lt;h3 id=&quot;linux-删除命令&quot;&gt;&lt;a href=&quot;#linux-删除命令&quot; class=&quot;headerlink&quot; title=&quot;linux 删除命
      
    
    </summary>
    
    
      <category term="ECS" scheme="http://yoursite.com/tags/ECS/"/>
    
  </entry>
  
  <entry>
    <title>linux的vim命令</title>
    <link href="http://yoursite.com/2018/09/17/linux%E7%9A%84vim%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/17/linux的vim命令/</id>
    <published>2018-09-17T07:04:49.000Z</published>
    <updated>2018-09-17T07:06:12.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进入vi的命令"><a href="#进入vi的命令" class="headerlink" title="进入vi的命令"></a>进入vi的命令</h3><pre><code>vi filename :打开或新建文件,并将光标置于第一行首vi n filename ：打开文件,并将光标置于第n行首vi filename ：打开文件,并将光标置于一行首vi /pattern filename：打开文件,并将光标置于第一个与pattern匹配的串处vi -r filename ：在上次正用vi编辑时发生系统崩溃,恢复filenamevi filename....filename ：打开多个文件,依次进行编辑</code></pre><h3 id="移动光标类命令"><a href="#移动光标类命令" class="headerlink" title="移动光标类命令"></a>移动光标类命令</h3><pre><code>h ：光标左移一个字符l ：光标右移一个字符space：光标右移一个字符Backspace：光标左移一个字符k或Ctrl p：光标上移一行j或Ctrl n ：光标下移一行Enter ：光标下移一行w或W ：光标右移一个字至字首b或B ：光标左移一个字至字首e或E ：光标右移一个字至字尾) ：光标移至句尾( ：光标移至句首}：光标移至段落开头{：光标移至段落结尾nG：光标移至第n行首n ：光标下移n行n-：光标上移n行n$：光标移至第n行尾H ：光标移至屏幕顶行M ：光标移至屏幕中间行L ：光标移至屏幕行0：（注意是数字零）光标移至当前行首$：光标移至当前行尾</code></pre><h3 id="屏幕翻滚类命令"><a href="#屏幕翻滚类命令" class="headerlink" title="屏幕翻滚类命令"></a>屏幕翻滚类命令</h3><pre><code>Ctrl u：向文件首翻半屏Ctrl d：向文件尾翻半屏Ctrl f：向文件尾翻一屏Ctrl＋b；向文件首翻一屏nz：将第n行滚至屏幕顶部,不指定n时将当前行滚至屏幕顶部.</code></pre><h3 id="插入文本类命令"><a href="#插入文本类命令" class="headerlink" title="插入文本类命令"></a>插入文本类命令</h3><pre><code>i ：在光标前I ：在当前行首a：光标后A：在当前行尾o：在当前行之下新开一行O：在当前行之上新开一行r：替换当前字符R：替换当前字符及其后的字符,直至按ESC键s：从当前光标位置处开始,以输入的文本替代指定数目的字符</code></pre><h3 id="保存命令"><a href="#保存命令" class="headerlink" title="保存命令"></a>保存命令</h3><pre><code>按ESC键 跳到命令模式，然后：:w   保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w!   强制保存，不推出vi:wq  保存文件并退出vi:wq! 强制保存文件，并退出viq:  不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进入vi的命令&quot;&gt;&lt;a href=&quot;#进入vi的命令&quot; class=&quot;headerlink&quot; title=&quot;进入vi的命令&quot;&gt;&lt;/a&gt;进入vi的命令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;vi filename :打开或新建文件,并将光标置于第一行首
vi n filen
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>git的撤销操作</title>
    <link href="http://yoursite.com/2018/08/20/git%E7%9A%84%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/08/20/git的撤销操作/</id>
    <published>2018-08-20T11:55:46.000Z</published>
    <updated>2018-08-20T17:47:42.708Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚在使用git commit之后要push，提示报错，原因就不多说了。特意总结了一下如果要撤销add或者commit操作应该怎么做,当然在git status的时候也会自动提示可以用什么操作(5月28日也有过一次对撤销的小结，当时仅仅是撤销文件的更改)<br><a id="more"></a></p><h3 id="撤销add"><a href="#撤销add" class="headerlink" title="撤销add"></a>撤销add</h3><p>git add 如果添加了错误的文件的话想要撤销</p><ol><li>git status 先看一下add 中的文件 </li><li>git reset HEAD 如果后面什么都不跟的话 就是回到上一次状态 add里面的全部撤销了<br>————–or—————</li><li>git reset HEAD <file> 就是对某个文件进行撤销了</file></li></ol><h3 id="撤销commit"><a href="#撤销commit" class="headerlink" title="撤销commit"></a>撤销commit</h3><p>已经commit了但是没有Push,想要撤销commit的内容</p><ol><li>找到之前提交的git commit的id<br>git log<br>找到想要撤销的id </li><li>git reset –hard id<br>完成撤销,同时将代码恢复到指定 id 对应的版本<br>————–or—————</li><li>git reset id<br>完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改</li></ol><h3 id="撤销文件的修改"><a href="#撤销文件的修改" class="headerlink" title="撤销文件的修改"></a>撤销文件的修改</h3><p>将本次对文件的所有修改撤销,直接对内容撤销的不是对暂存区</p><p>git checkout – <file></file></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚刚在使用git commit之后要push，提示报错，原因就不多说了。特意总结了一下如果要撤销add或者commit操作应该怎么做,当然在git status的时候也会自动提示可以用什么操作(5月28日也有过一次对撤销的小结，当时仅仅是撤销文件的更改)&lt;br&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>迟到的暑期培训总结</title>
    <link href="http://yoursite.com/2018/08/20/%E6%9A%91%E6%9C%9F%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/"/>
    <id>http://yoursite.com/2018/08/20/暑期总结报告/</id>
    <published>2018-08-19T17:56:56.000Z</published>
    <updated>2018-08-20T11:12:44.905Z</updated>
    
    <content type="html"><![CDATA[<p>早就应该写的了，拖着拖着就到现在了<br><a id="more"></a></p><h3 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h3><ul><li><p>开张的前几天，做牛做马当木工，总算是把原本空荡荡的房间变得有模有样了</p></li><li><p>之后的前半段时间真的是被奥克斯的hot wind 逼疯了，在空调师傅的师傅拯救下终于感受到了什么是凉爽，虽然空调修好后一堆人感冒生病(AUX:这锅我背了)</p></li><li><p>期间大爷和holy经常拍大家伙的黑照，然后P表情包，中午大致三足鼎立 开黑打王者，肝痒痒鼠，睡觉；晚上吃完饭后也是王者，吃鸡，阴阳师，元气，看番看剧</p></li><li><p>经历了两碗的生日party，那晚的场面一度混乱，一切都是从大爷反手往我脸上一糊开始~~~</p></li><li><p>培训时间进入尾期的时候，，看了几天的电影(无间道：这锅我背了)，不得不说无间道真的好看，还有傻嗨三宝看沙海，附上宝图一张</p></li></ul><p><img src="暑期总结报告/1234.png" width="256" height="256"></p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>还是学会了挺多东西，虽然也有很多东西还没学<br>进行一波非常简洁的概括，可能会漏掉一些(详情请见之前的博文)</p><ul><li>知道git的多人合作流程</li><li>有了自己的云服务器</li><li>http和https的瓜葛</li><li>深入了解事件循环机制</li><li>js基础知识譬如继承、作用域、上下文</li><li>express的各种操作</li><li>HTML和CSS基础的学了，可以做出像新世界这种简单的界面了</li><li>做项目的时候经历了各种逻辑风暴和BUG袭击</li><li>Affair项目后台方面剩下一个消息界面的逻辑实在是搞不清，绕来绕去都是不妥的，其他的接口已经写好并测试完毕(有一些我是觉得逻辑上还能更清晰的，但是现在没有技术)，然而对接并没有完成</li></ul><p>放假在家也是会继续学习的，学习使我快乐</p><h3 id="从化之旅"><a href="#从化之旅" class="headerlink" title="从化之旅"></a>从化之旅</h3><p>开门见山：这次从化别墅温泉之旅真的是非常非常嗨森✧<em>｡٩(ˊᗜˋ</em>)و✧*｡</p><ul><li>在华润万家大扫购并达成了1436会师，之后一起滴滴前往别墅</li><li>初入别墅，四层(还是五层？)的设计，温泉，烧烤摊，电影房，桌游房，麻将房，唱K区应有尽有</li><li>当天下午大一的唱K(前半场是浩立和大爷的主场，后半场是屹彬的主场)，大二的做饭，此处表扬居家好男人林荣耀，不仅代码敲得溜、天天跑业务、还能烧得一手好菜，可谓是出得厅堂入得厨房，品尝到了周老板做的超级美味的传说中的海底捞版本的面筋塞蛋和小恬恬香喷喷的炒饭</li><li>吃完饭轮到大一的负责准备晚上烧烤用的食材，大二的去休息唱K啦(小恬恬唱的贼好听)<br>晚上，国家一级烧烤运动员jio大爷和周老板的烧烤摊开张，其他人则是在旁边打UNO嗷嗷待哺</li><li>人生第一次泡温泉，这个水温有毒，经久不衰盖如此乎，经过温泉水洗礼整个人都要升天了</li><li>半夜因为看不了电影，就一堆人挤在2张床上听所谓的恐怖故事，然而并没有发觉哪里恐怖，催眠了一个菠萝就有的。</li><li>之后除了麻将组决战到天光其他人差不多都是4点多回各自的房间训教了</li><li>第二天早上收拾东西走人，吃了一顿丰盛的早午餐就搭车翻来了</li></ul><font size="5" color="#D9D9F3" face="Georgia"><br>前进吧<br>无需鲜衣怒马<br>不用壮志豪言<br><br></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早就应该写的了，拖着拖着就到现在了&lt;br&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>https协议二次了解</title>
    <link href="http://yoursite.com/2018/08/19/https%E5%8D%8F%E8%AE%AE%E4%BA%8C%E6%AC%A1%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/19/https协议二次了解/</id>
    <published>2018-08-19T09:49:15.000Z</published>
    <updated>2018-08-19T10:27:12.769Z</updated>
    
    <content type="html"><![CDATA[<p>7月14日的时候学习到了http的一些事项，三次握手，跨域，缓存,csp等等，以及https相比http的一些优势，在这里再次深入了解一下https<br><a id="more"></a></p><h3 id="HTTPS的基本概念"><a href="#HTTPS的基本概念" class="headerlink" title="HTTPS的基本概念"></a>HTTPS的基本概念</h3><blockquote><p>HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></blockquote><blockquote><p>大特点也是优势有：数据加密、信道复用、分帧传输</p></blockquote><blockquote><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p></blockquote><h3 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h3><blockquote><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p></blockquote><h3 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h3><blockquote><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。<br><img src="1-150H120343I41.jpg" alt=""></p></blockquote><blockquote><p>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p></blockquote><blockquote><p>（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p></blockquote><blockquote><p>（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p></blockquote><blockquote><p>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p></blockquote><blockquote><p>（5）Web服务器利用自己的私钥解密出会话密钥。</p></blockquote><blockquote><p>（6）Web服务器利用会话密钥加密与客户端之间的通信。<br><img src="2012071410212142.gif" alt=""></p></blockquote><h3 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h3><blockquote><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p></blockquote><blockquote><p>（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%；   </p></blockquote><blockquote><p>（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p></blockquote><blockquote><p>（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p></blockquote><blockquote><p>（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p></blockquote><blockquote><p>（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;7月14日的时候学习到了http的一些事项，三次握手，跨域，缓存,csp等等，以及https相比http的一些优势，在这里再次深入了解一下https&lt;br&gt;
    
    </summary>
    
    
      <category term="https" scheme="http://yoursite.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>token机制二次学习</title>
    <link href="http://yoursite.com/2018/07/31/token%E6%9C%BA%E5%88%B6%E4%BA%8C%E6%AC%A1%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/07/31/token机制二次学习/</id>
    <published>2018-07-31T07:59:34.000Z</published>
    <updated>2018-08-20T17:46:12.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传统的session认证"><a href="#传统的session认证" class="headerlink" title="传统的session认证"></a>传统的session认证</h2><p>   HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。</p><p>   解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。</p><p>   上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。</p><p>   但是这种基于session的认证使应用本身很难得扩展，随着不用客户端的增加，独立的服务器已无法承载更多的用户，而这个时候基于session认证应用的问题就会暴露出来</p><h2 id="基于token机制的认证"><a href="#基于token机制的认证" class="headerlink" title="基于token机制的认证"></a>基于token机制的认证</h2><p>使用token机制的身份验证方法，在服务器端不需要存储用户的登录记录。大概的流程：</p><ul><li>客户端使用用户名和密码请求登录。</li><li>服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个token，然后把这个token发送给客户端。</li><li>客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。</li><li>客户端每次向服务端发送请求的时候都需要带上服务端发给的token。</li><li>服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。</li></ul><p>相比于传统sessionid都要存起来，token可以存到数据库中，但是有可能查询token的时间会过长导致token丢失（其实token丢失了再重新认证一个就好，但是别丢太频繁，别让用户没事儿就去认证）。</p><p>为了避免查询时间过长，可以将token放到内存中。这样查询速度绝对就不是问题了，也不用太担心占据内存，占不了多少内存的。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT由三部分构成   头部（header）载荷（payload）签名（signature）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">header</span><br><span class="line">&#123;</span><br><span class="line">     <span class="string">'typ'</span>:<span class="string">'JWT'</span>, <span class="comment">//类型</span></span><br><span class="line">     <span class="string">'alg'</span>:<span class="string">'HS256'</span>  <span class="comment">//加密算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload</span><br><span class="line">&#123;  原有注册声明</span><br><span class="line">    iss：jwt签发者</span><br><span class="line">    sub：jwt所面向的用户</span><br><span class="line">    aud：接收jwt的一方</span><br><span class="line">    exp：jwt的过期时间，这个过期时间必须大于签发时间</span><br><span class="line">    nbf：定义在什么时间之前，该jwt都是不可用的</span><br><span class="line">    iat：jwt的签发时间</span><br><span class="line">    jti：jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击 </span><br><span class="line"></span><br><span class="line">    公共的声明可以添加任何的信息，一般添加用户的相关信息</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"beichen"</span></span><br><span class="line">    <span class="string">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第三部分signature需要header+payload+secret</span><br><span class="line">secret是密钥，可以是随便打的字符串 (我记得string或者buffer类型？)</span><br><span class="line">secret是保存在服务器端的，jwt的签发也是在服务端的，secret就是用来进行jwt的签发和jwt的验证，所以它就是你服务端的私钥，在任何场景都不应该流露出去，一旦客户端得知这个secret，那就意味着客户端可以自我签发jwt了</span><br></pre></td></tr></table></figure><h2 id="在node中JWT的应用"><a href="#在node中JWT的应用" class="headerlink" title="在node中JWT的应用"></a>在node中JWT的应用</h2><p>用本次项目的应用举例</p><p>在这个token.js文件里，我是先封装了两个方法，一个用来生成token，一个用来解密<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);</span><br><span class="line"><span class="keyword">const</span> secret = <span class="string">'zxc'</span> </span><br><span class="line"></span><br><span class="line">getToken = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jwt.sign(data, secret, &#123;</span><br><span class="line">        expiresIn: <span class="string">"168h"</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getVerify = <span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jwt.verify(token,secret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    getToken,</span><br><span class="line">    getVerify</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在其他涉及到token的地方，导入上面的js文件后就可以直接调用两个方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">登录时生成token并返回给客户端</span><br><span class="line">router.get(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> data = &#123;</span><br><span class="line">        username : <span class="string">'testAccount'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> token = jwt.getToken(data)</span><br><span class="line">    <span class="comment">//  var username = jwt.getVerify(token).username</span></span><br><span class="line">    res.json(&#123;</span><br><span class="line">      code:<span class="number">200</span>,</span><br><span class="line">      username:data.username,</span><br><span class="line">      userphoto:data.userphoto,</span><br><span class="line">      token</span><br><span class="line">     </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jwt = <span class="built_in">require</span>(<span class="string">'./token'</span>);</span><br><span class="line">router.post(<span class="string">'*'</span>, (req, res,next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> token = req.body.token;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jwt.getVerify(token);<span class="comment">//因为是写成同步操作，所以可能出现异常，要自行捕获</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Token过期'</span>)</span><br><span class="line">       <span class="keyword">return</span> res.json(&#123;</span><br><span class="line">              msg: <span class="string">'Token过期'</span></span><br><span class="line">               &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Token未过期'</span>)</span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;传统的session认证&quot;&gt;&lt;a href=&quot;#传统的session认证&quot; class=&quot;headerlink&quot; title=&quot;传统的session认证&quot;&gt;&lt;/a&gt;传统的session认证&lt;/h2&gt;&lt;p&gt;   HTTP 是一种没有状态的协议，也就是它并不知道是谁是
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>Affair开发初步想法</title>
    <link href="http://yoursite.com/2018/07/24/Affair%E5%BC%80%E5%8F%91%E5%88%9D%E6%AD%A5%E6%83%B3%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/24/Affair开发初步想法/</id>
    <published>2018-07-24T15:41:03.000Z</published>
    <updated>2018-08-20T07:43:04.661Z</updated>
    
    <content type="html"><![CDATA[<p>今天学到的和初步想法<br><a id="more"></a></p><h4 id="有关如何判断登录状态的简单想法"><a href="#有关如何判断登录状态的简单想法" class="headerlink" title="有关如何判断登录状态的简单想法"></a>有关如何判断登录状态的简单想法</h4><p>一个鉴定函数判断是不是原来的用户（密码错误，全错等）<br>写一个islogined函数 用来判断是否登录状态，调用到authenticate，因为参数取的是req.cookie.如果cookie过时了就空，以此返回不同的值</p><h4 id="get到的新知识"><a href="#get到的新知识" class="headerlink" title="get到的新知识"></a>get到的新知识</h4><p>app.use(‘/‘, users); 这样子写是将users下所有中间件启动</p><blockquote><p>app.get(env) === development 与 process.env.NODE_ENV === ‘development’ 的区别<br>app.get(env)获取的是env的值；<br>process.env.NODE_ENV获取的是 env上面NODE_ENV的值；<br>这两行代码在express中都有出现，意思；<br>还有就是 我们平时写代码一般都是 本地用开发版本；线上用生产版本<br>本地开发版本默认 app.get(env) = development；<br>线上生产版本的环境设置的就是app.get(env) = production;</p></blockquote><h4 id="crypto最简单的用法"><a href="#crypto最简单的用法" class="headerlink" title="crypto最简单的用法"></a>crypto最简单的用法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>)</span><br><span class="line"><span class="keyword">var</span> hash=crypto.createHash(<span class="string">'md5'</span>)调用加密算法，常用md5</span><br><span class="line">hash.update(userName+pwd)</span><br><span class="line"><span class="keyword">return</span> hash.digest(<span class="string">'hex'</span>)十六进制</span><br></pre></td></tr></table></figure><h3 id="正文：构想（跟咕咕咕的交流过程中随笔）-旁人看不懂滴"><a href="#正文：构想（跟咕咕咕的交流过程中随笔）-旁人看不懂滴" class="headerlink" title="正文：构想（跟咕咕咕的交流过程中随笔）(旁人看不懂滴)"></a>正文：构想（跟咕咕咕的交流过程中随笔）(旁人看不懂滴)</h3><p>稍微理一下思路<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">post(,fun&#123;</span><br><span class="line">reddot fn</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">reddot fn&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">评论&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">user schema&#123;</span><br><span class="line">头像:</span><br><span class="line">ID:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event schema&#123;</span><br><span class="line">发布id::</span><br><span class="line">涉及id：[ ]</span><br><span class="line">标题：</span><br><span class="line">状态：[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">comment &#123;</span><br><span class="line">id:</span><br><span class="line">content:</span><br><span class="line">date&#123; <span class="keyword">var</span> time=<span class="keyword">new</span> <span class="built_in">Date</span>( )</span><br><span class="line"> time.toString&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>创建小组的功能，设计说不需要做了，倒是省了很多事，不过我想真的做出来后，之后的之后也许会继续完善<br>最大的难题是如何做到微信授权登录，获取微信用户的信息。尝试了putty配置，ngrok生成外网域名然后内网映射过去，查了资料，如何内网映射外网，内网穿透，最后发现貌似不需要内网穿透？？！！接下来先把能做的逻辑写出来，以及等一波菠萝的教学有关于微信授权的技能</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学到的和初步想法&lt;br&gt;
    
    </summary>
    
    
      <category term="Affair" scheme="http://yoursite.com/tags/Affair/"/>
    
  </entry>
  
  <entry>
    <title>练手项目开始</title>
    <link href="http://yoursite.com/2018/07/23/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2018/07/23/练手项目开始/</id>
    <published>2018-07-22T16:45:32.000Z</published>
    <updated>2018-08-20T07:55:30.156Z</updated>
    
    <content type="html"><![CDATA[<p>设计稿交给我们了，前半天让张阳宁给我指导下做页面的事项，后半天想一下affair<br><a id="more"></a></p><h3 id="前端方面get到的小知识"><a href="#前端方面get到的小知识" class="headerlink" title="前端方面get到的小知识"></a>前端方面get到的小知识</h3><p>今天从中午开始就一直在做一个页面，因为是第一次做网页(除教程外的第一个)，遇到了很多很多的问题，我想做熟练了写起代码来应该就会得心应手很多吧。</p><p>get到一些很基础的 写页面的时候用到的技巧（至少目前我是这样被教育的）</p><ol><li><p>*{<br> margin: 0;<br> padding: 0;<br>}</p></li><li><p>背景填充用background-size: cover;</p></li><li><p>想要实现同行排列几个块的时候<br>对父级div设置font-size:0px<br>对小块div用display: inline-block<br>一般还对小块div设置margin:0px和width:占比%；</p></li><li><p>float浮动和clear 尽量不要乱用，惨痛</p></li><li><p>新学到的  cursor: pointer;鼠标指针样式</p></li></ol><h3 id="后台方面"><a href="#后台方面" class="headerlink" title="后台方面"></a>后台方面</h3><p>  今天设计正式提出了接下来的Affair项目功能需求，涉及的东西挺多<br>  接下来要做的东西中“较为可行”的 如何授权微信登录 实现点赞 评论（后面两个还行，第一个看下教学吧） 发布任务<br>  最难搞的还是那些逻辑，毕竟是以前没有做过的things，真实情况也的确是难度很大，开发不完应该是板上钉钉，但是也会拼尽全力去实现的！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计稿交给我们了，前半天让张阳宁给我指导下做页面的事项，后半天想一下affair&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="http://yoursite.com/2018/07/21/flex%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/07/21/flex布局/</id>
    <published>2018-07-21T15:47:03.000Z</published>
    <updated>2018-08-20T07:50:00.121Z</updated>
    
    <content type="html"><![CDATA[<p>今天学习了flex布局，这个布局还是挺方便的，不然老是float太多问题了<br><a id="more"></a></p><h3 id="flex由来"><a href="#flex由来" class="headerlink" title="flex由来"></a>flex由来</h3><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。W3C 提出了一种新的方案—-Flex 布局（弹性布局），可以简便、完整、响应式地实现各种页面布</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>任何一个容器都可以指定为 Flex 布局。   display: flex;<br>行内元素也可以使用 Flex 布局。         display: inline-flex;<br>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</p><h3 id="六大属性"><a href="#六大属性" class="headerlink" title="六大属性"></a>六大属性</h3><h4 id="flex-direction-决定主轴的方向"><a href="#flex-direction-决定主轴的方向" class="headerlink" title="flex-direction(决定主轴的方向)"></a>flex-direction(决定主轴的方向)</h4><p>row（默认值）：主轴为水平方向，起点在左端。<br>row-reverse：<br>column：<br>column-reverse:</p><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><blockquote><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p></blockquote><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>nowrap（默认）：不换行。<br>wrap：换行，第一行在上<br>wrap-reverse：换行，第一行在下方。</p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>属性定义了项目在主轴上的对齐方式。<br>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目<em>之间</em>的间隔都相等。<br>space-around：每个项目<em>两侧</em>的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>属性定义项目在交叉轴上如何对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度<br>flex-start：交叉轴的起点对齐。<br>flex-end：交叉轴的终点对齐。<br>center：交叉轴的中点对齐。<br>baseline: 项目的第一行文字的基线对齐。</p><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br>stretch（默认值）：轴线占满整个交叉轴。<br>flex-start：与交叉轴的起点对齐。<br>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</p><h3 id="对于项目item使用的属性"><a href="#对于项目item使用的属性" class="headerlink" title="对于项目item使用的属性"></a>对于项目item使用的属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>属性定义项目的放大比例，默认为0，意思是如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>在分配多余空间之前项目占据的主轴空多大。以如果设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>属性是前面三个的简写，默认0 1 auto<br>两个快捷方式 auto（1 1 auto）<br>                       none （0 0 auto）</p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天学习了flex布局，这个布局还是挺方便的，不然老是float太多问题了&lt;br&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>2018/07/19</title>
    <link href="http://yoursite.com/2018/07/19/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E7%AC%AC%E4%B8%83%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/07/19/后台进化史之第七天/</id>
    <published>2018-07-19T15:53:19.000Z</published>
    <updated>2018-08-20T07:53:33.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络层相关"><a href="#网络层相关" class="headerlink" title="网络层相关"></a>网络层相关</h2><p>网关实质上是一个网络通向其他网络的IP地址<br>主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机（如附图所示）。网络A向网络B转发数据包的过程</p><h2 id="继续学习CSS"><a href="#继续学习CSS" class="headerlink" title="继续学习CSS"></a>继续学习CSS</h2><p>看了瀚程给大爷的新时代修BUG获益匪浅</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网络层相关&quot;&gt;&lt;a href=&quot;#网络层相关&quot; class=&quot;headerlink&quot; title=&quot;网络层相关&quot;&gt;&lt;/a&gt;网络层相关&lt;/h2&gt;&lt;p&gt;网关实质上是一个网络通向其他网络的IP地址&lt;br&gt;主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>2018/07/18</title>
    <link href="http://yoursite.com/2018/07/18/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/07/18/后台进化史之第六天/</id>
    <published>2018-07-18T15:30:53.000Z</published>
    <updated>2018-08-20T07:53:18.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><ul><li><p>express xx生成一个express文件，进入bin，npm start 等同于node ./bin/www 运行node服务</p></li><li><p>package.json下列出的模块表明是运行所需要的，npm install 会自行安装。便于客户端执行服务。</p></li><li><p>jade模板引擎，在express开发中有粗略看过，当初还没学前端htmlcss基本懵逼，现在看好多了。模板引擎是用来简化html代码的，准备晚点再看看。</p></li><li><p>路由通配符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.post(<span class="string">'*'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">   xxxxxx;</span><br><span class="line">   next()；</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>路径如果设定是*，表明所有的请求都要经过这个路由，再执行next方法，比如用来检测用户在一个页面停留的时间是否过长，从而判断登录状态。</p></li></ul><h2 id="继续学css"><a href="#继续学css" class="headerlink" title="继续学css"></a>继续学css</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;express&quot;&gt;&lt;a href=&quot;#express&quot; class=&quot;headerlink&quot; title=&quot;express&quot;&gt;&lt;/a&gt;express&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;express xx生成一个express文件，进入bin，npm start 等
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>继承、执行上下文、this浅理解</title>
    <link href="http://yoursite.com/2018/07/17/%E7%BB%A7%E6%89%BF%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81this/"/>
    <id>http://yoursite.com/2018/07/17/继承、执行上下文、this/</id>
    <published>2018-07-17T14:16:23.000Z</published>
    <updated>2018-08-19T17:22:08.307Z</updated>
    
    <content type="html"><![CDATA[<p>早上瀚程扔了一个王福朋的博客，里面讲了很多有关JS CSS的东西。早上听讲了原型链，this，执行上下文等，回头也结合王福朋的博客看了一点。</p><ul><li>对象都是通过函数来创建的，但是函数又是一种对象（万物皆对象）</li><li>每一个函数都有一个prototype属性，这个属性的值是一个对象（属性集合），默认的只有一个构造器函数constructor，指向函数本身。</li><li>每个对象都有一个隐藏的属性——“<strong>proto</strong>”，这个属性引用了创建这个对象的函数的prototype。即：fn.<strong>proto</strong> === Fn.prototype</li></ul><blockquote><p>下面是一个经典的例子<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="keyword">Fn</span><span class="params">()</span> &#123; &#125;</span></span><br><span class="line"><span class="function">        <span class="keyword">Fn</span>.prototype.<span class="title">name</span> = '王福朋'</span>;</span><br><span class="line">        <span class="function"><span class="keyword">Fn</span>.prototype.<span class="title">getYear</span> = function <span class="params">()</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="keyword">return</span> <span class="number">1988</span></span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var <span class="function"><span class="keyword">fn</span> = <span class="keyword">new</span> <span class="keyword">Fn</span><span class="params">()</span></span>;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="function"><span class="keyword">fn</span>.name)</span>;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="function"><span class="keyword">fn</span>.getYear<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<strong>proto</strong>这条链向上找，这就是原型链。</p></li><li><p>由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。</p></li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>通俗说法在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。</p><h3 id="this的取值"><a href="#this的取值" class="headerlink" title="this的取值"></a>this的取值</h3><p><em><font color="green">在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了</font></em><br>分为四种情况，震惊，这么详细</p><blockquote><p>1、 构造函数中this指向new出来的对象<br>2、 函数作为对象的一个属性，并且被调用,this指向这个对象，如果作为属性但是不被调用，还是指向window<br>3、 函数用call或者apply调用，this的值取传入的参数（对象）的值<br>4、 全局下this指向window，普通函数调用的时候也是指向window</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;早上瀚程扔了一个王福朋的博客，里面讲了很多有关JS CSS的东西。早上听讲了原型链，this，执行上下文等，回头也结合王福朋的博客看了一点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象都是通过函数来创建的，但是函数又是一种对象（万物皆对象）&lt;/li&gt;
&lt;li&gt;每一个函数都有一个prot
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>express处理表单浅理解</title>
    <link href="http://yoursite.com/2018/07/16/express%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95%E6%B5%85%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/07/16/express处理表单浅理解/</id>
    <published>2018-07-16T14:25:56.000Z</published>
    <updated>2018-08-19T17:16:34.738Z</updated>
    
    <content type="html"><![CDATA[<p><font face="Georgia" size="4" color="cray">了解了使用express框架如何处理表单请求</font></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>当表单被提交（通过浏览器或AJAX）时，必须被编码。如果没有明确地指定编码，则默认为application/x-wwwform-urlencoded。<br>如果需要上传文件，使用multipart/form-data编码类型（并不被建议使用）。</p><h3 id="处理表单的不同方式"><a href="#处理表单的不同方式" class="headerlink" title="处理表单的不同方式"></a>处理表单的不同方式</h3><p>如果method=”POST”m展示表单和处理表单可以用同一个路由，因为展示只需要get请求，而处理一般是post请求，使用同一个路由是可以区分的，这一点我当初在做考核的时候倒是没有考虑到。</p><h3 id="处理完后如何响应"><a href="#处理完后如何响应" class="headerlink" title="处理完后如何响应"></a>处理完后如何响应</h3><p>1、 直接响应html，就是直接扔一个html<br>2、 303重定向 { 重定向到某一个特殊的界面，跳转成功应该去哪里，404定制界面等}</p><h3 id="表单域的获取"><a href="#表单域的获取" class="headerlink" title="表单域的获取"></a>表单域的获取</h3><p>1、对于GET请求 域放在req,query<br>2、对于POST请求，域放在req.body中，需要引入一个body-parser 很常用的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font face=&quot;Georgia&quot; size=&quot;4&quot; color=&quot;cray&quot;&gt;了解了使用express框架如何处理表单请求&lt;/font&gt;&lt;/p&gt;
&lt;h3 id=&quot;编码&quot;&gt;&lt;a href=&quot;#编码&quot; class=&quot;headerlink&quot; title=&quot;编码&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>事件循环机制和几种数组方法</title>
    <link href="http://yoursite.com/2018/07/16/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E5%87%A0%E7%A7%8D%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/16/事件循环机制和几种数组方法/</id>
    <published>2018-07-15T16:00:00.000Z</published>
    <updated>2018-08-19T17:07:36.067Z</updated>
    
    <content type="html"><![CDATA[<font face="STCAIYUN" color="gray" size="6">Everything runs in parallel except your code!</font><h3 id="事件循环（以及异步，回调）"><a href="#事件循环（以及异步，回调）" class="headerlink" title="事件循环（以及异步，回调）"></a>事件循环（以及异步，回调）</h3><p>js 事件轮询机制</p><blockquote><p>在js中同步和异步的任务会分别进入不同的执行场所，同步任务进入主线程异步的进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的Event Loop(事件循环)。<br><img src="2018041120124254.png" alt="Alt text"></p></blockquote><blockquote><p>但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。<img src="20180411202638415.png" alt="Alt text"></p></blockquote><p>菠萝说的<br>宏任务一般有：script，setTimeout，setInterval。</p><p>微任务：Promise，process.nextTick。</p><h3 id="数组操作几种方法-codewar"><a href="#数组操作几种方法-codewar" class="headerlink" title="数组操作几种方法(codewar)"></a>数组操作几种方法(codewar)</h3><blockquote><p>今天做的这道题让我回忆，以及get到了一些或旧或新的方法，这些方法都是挺有用的</p></blockquote><h4 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter()过滤"></a>filter()过滤</h4><p>filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</p><blockquote><p>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="number">2</span> <span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line"><span class="number">4</span> &#125;);</span><br><span class="line"><span class="number">5</span> r; <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure></p></blockquote><h4 id="split-分隔"><a href="#split-分隔" class="headerlink" title="split()分隔"></a>split()分隔</h4><blockquote><p>分割字符串的方法<br>注意这两个<br>split(“”) 每个元素分隔<br>split(“ “)以空格为分隔符分隔</p></blockquote><h4 id="几种遍历方法"><a href="#几种遍历方法" class="headerlink" title="几种遍历方法"></a>几种遍历方法</h4><blockquote><p>回顾了一下js数组遍历的几种方法<br>1、 普通for循环,最简单的一种，也是使用频率最高的一种，瀚程如是说，的确是最熟悉性能也是挺高</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; arr.<span class="built_in">length</span>; <span class="built_in">j</span>++) &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2、 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>.prototype.<span class="keyword">forEach</span>.call(arr,<span class="function"><span class="keyword">function</span><span class="params">(el)</span></span>&#123;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4、</p><pre><code>for(i in或者of  arr){}</code></pre><p>5、 map遍历</p><pre><code>arr.map(funtion(n){})</code></pre><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>记录类型A 表明主机记录指向唯一的IP<br>记录类型CNAME 一个域名指向另一个域名</p><p>买了一个新的域名尝试了将其指向原有的博客域名，一顿操作终于好了<br>缓存真是个奇怪的东西，明明就是ping一样的地址，上一刻和下一刻效果不一样</p><h3 id="添加虚拟主机的常用命令"><a href="#添加虚拟主机的常用命令" class="headerlink" title="添加虚拟主机的常用命令"></a>添加虚拟主机的常用命令</h3><p>lnmp vhost add<br>lnmp vhost list<br>cd /home wwwroot/<br>lnmp list<br>cd 进去 找到index.html，vim模式编辑</p><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><blockquote><p>Post请求体</p><ul><li>常用媒体类型是application/x-www-form-urlencoded</li><li>如果需要上传文件 multipart/form-data</li><li>如果是AJAX请求 application/json</li></ul></blockquote><h2 id="最后附上一道题，有关异步的"><a href="#最后附上一道题，有关异步的" class="headerlink" title="最后附上一道题，有关异步的"></a>最后附上一道题，有关异步的</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>这段代码的运行顺序 2，4，3，1<br>原因就是 然后回到开头的代码。因为settimeout是宏任务，虽然先执行的他，但是他被放到了宏任务的eventqueue里面，然后代码继续往下检查看有没有微任务，检测到Promise的then函数把他放入了微任务序列。等到主线进程的所有代码执行结束后。先从微任务queue里拿回掉函数，然后微任务queue空了后再从宏任务的queue拿函数。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font face=&quot;STCAIYUN&quot; color=&quot;gray&quot; size=&quot;6&quot;&gt;Everything runs in parallel except your code!&lt;/font&gt;



&lt;h3 id=&quot;事件循环（以及异步，回调）&quot;&gt;&lt;a href=&quot;#事件循环（以及
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
</feed>
