<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星辰在上</title>
  
  <subtitle>万物皆虚，万物皆允</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-19T10:27:12.769Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郑庆义</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>https协议二次了解</title>
    <link href="http://yoursite.com/2018/08/19/https%E5%8D%8F%E8%AE%AE%E4%BA%8C%E6%AC%A1%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/08/19/https协议二次了解/</id>
    <published>2018-08-19T09:49:15.000Z</published>
    <updated>2018-08-19T10:27:12.769Z</updated>
    
    <content type="html"><![CDATA[<p>7月14日的时候学习到了http的一些事项，三次握手，跨域，缓存,csp等等，以及https相比http的一些优势，在这里再次深入了解一下https<br><a id="more"></a></p><h3 id="HTTPS的基本概念"><a href="#HTTPS的基本概念" class="headerlink" title="HTTPS的基本概念"></a>HTTPS的基本概念</h3><blockquote><p>HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></blockquote><blockquote><p>大特点也是优势有：数据加密、信道复用、分帧传输</p></blockquote><blockquote><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p></blockquote><h3 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h3><blockquote><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p></blockquote><h3 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h3><blockquote><p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。<br><img src="/2018/08/19/https协议二次了解/1-150H120343I41.jpg" alt=""></p></blockquote><blockquote><p>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p></blockquote><blockquote><p>（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p></blockquote><blockquote><p>（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p></blockquote><blockquote><p>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p></blockquote><blockquote><p>（5）Web服务器利用自己的私钥解密出会话密钥。</p></blockquote><blockquote><p>（6）Web服务器利用会话密钥加密与客户端之间的通信。<br><img src="/2018/08/19/https协议二次了解/2012071410212142.gif" alt=""></p></blockquote><h3 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点"></a>HTTPS缺点</h3><blockquote><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p></blockquote><blockquote><p>（1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%；   </p></blockquote><blockquote><p>（2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p></blockquote><blockquote><p>（3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p></blockquote><blockquote><p>（4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p></blockquote><blockquote><p>（5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;7月14日的时候学习到了http的一些事项，三次握手，跨域，缓存,csp等等，以及https相比http的一些优势，在这里再次深入了解一下https&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="https" scheme="http://yoursite.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Affair开发初步想法</title>
    <link href="http://yoursite.com/2018/07/24/Affair%E5%BC%80%E5%8F%91%E5%88%9D%E6%AD%A5%E6%83%B3%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/24/Affair开发初步想法/</id>
    <published>2018-07-24T15:41:03.000Z</published>
    <updated>2018-07-24T16:44:56.415Z</updated>
    
    <content type="html"><![CDATA[<h4 id="有关如何判断登录状态的简单想法"><a href="#有关如何判断登录状态的简单想法" class="headerlink" title="有关如何判断登录状态的简单想法"></a>有关如何判断登录状态的简单想法</h4><p>一个鉴定函数判断是不是原来的用户（密码错误，全错等）<br>写一个islogined函数 用来判断是否登录状态，调用到authenticate，因为参数取的是req.cookie.如果cookie过时了就空，以此返回不同的值</p><h4 id="get到的新知识"><a href="#get到的新知识" class="headerlink" title="get到的新知识"></a>get到的新知识</h4><p>app.use(‘/‘, users); 这样子写是将users下所有中间件启动</p><blockquote><p>app.get(env) === development 与 process.env.NODE_ENV === ‘development’ 的区别<br>app.get(env)获取的是env的值；<br>process.env.NODE_ENV获取的是 env上面NODE_ENV的值；<br>这两行代码在express中都有出现，意思；<br>还有就是 我们平时写代码一般都是 本地用开发版本；线上用生产版本<br>本地开发版本默认 app.get(env) = development；<br>线上生产版本的环境设置的就是app.get(env) = production;</p></blockquote><h4 id="crypto最简单的用法"><a href="#crypto最简单的用法" class="headerlink" title="crypto最简单的用法"></a>crypto最简单的用法</h4><p>导入后， var hash=crypto.createHash(‘md5’)调用加密算法，常用md5<br>hash.update(userName+pwd)<br>return hash.digest(‘hex’)十六进制</p><h3 id="正文：构想（跟咕咕咕的交流过程中随笔）-外人看不懂滴"><a href="#正文：构想（跟咕咕咕的交流过程中随笔）-外人看不懂滴" class="headerlink" title="正文：构想（跟咕咕咕的交流过程中随笔）(外人看不懂滴)"></a>正文：构想（跟咕咕咕的交流过程中随笔）(外人看不懂滴)</h3><p>稍微理一下思路<br>post(,fun{<br>reddot fn<br>})</p><p>reddot fn{<br>}</p><hr><p>评论{<br>}</p><hr><p>user schema{<br>头像:<br>ID:<br>}</p><p>event schema{<br>发布id::<br>涉及id：[ ]<br>标题：<br>状态：[1 2 3]<br>}</p><p>comment {<br>id:<br>content:<br>date{ var time=new Date( )<br> time.toString}<br>}</p><hr><p>创建小组的功能，设计说不需要做了，倒是省了很多事，不过我想真的做出来后，之后的之后也许会继续完善<br>最大的难题是如何做到微信授权登录，获取微信用户的信息。尝试了putty配置，ngrok生成外网域名然后内网映射过去，查了资料，如何内网映射外网，内网穿透，最后发现貌似不需要内网穿透？？！！接下来先把能做的逻辑写出来，以及等一波菠萝的教学有关于微信授权的技能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;有关如何判断登录状态的简单想法&quot;&gt;&lt;a href=&quot;#有关如何判断登录状态的简单想法&quot; class=&quot;headerlink&quot; title=&quot;有关如何判断登录状态的简单想法&quot;&gt;&lt;/a&gt;有关如何判断登录状态的简单想法&lt;/h4&gt;&lt;p&gt;一个鉴定函数判断是不是原来的用户（密
      
    
    </summary>
    
    
      <category term="Affair" scheme="http://yoursite.com/tags/Affair/"/>
    
  </entry>
  
  <entry>
    <title>后台进化正史之第一天</title>
    <link href="http://yoursite.com/2018/07/23/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E6%AD%A3%E5%8F%B2%E4%B9%8B%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/07/23/后台进化正史之第一天/</id>
    <published>2018-07-22T16:45:32.000Z</published>
    <updated>2018-07-22T17:13:45.580Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端方面"><a href="#前端方面" class="headerlink" title="前端方面"></a>前端方面</h3><p>今天从中午开始就一直在做一个页面，因为是第一次做网页(除教程外的第一个)，遇到了很多很多的问题，我想做熟练了写起代码来应该就会得心应手很多吧。</p><p>get到一些很基础的 写页面的时候用到的技巧（至少目前我是这样被教育的）</p><p>*{<br>    margin: 0;<br>    padding: 0;<br>}</p><p>背景用background-size: cover;</p><p>用display: inline-block;是对需要同行排列的div操作，一般还要设置margin:0px和width：占比%；对父级div设置font-size：0px;</p><p>记得还有relative相对布局，老是不想用它<br>float浮动 尽量不要乱用，惨痛</p><p>新学到的 cursor: pointer;<br> overflow: hidden;</p><p> 这个页面肯定是还没有做完啦，第一次尝试做一个页面做怎么可能半天就搞定</p><h3 id="后台方面"><a href="#后台方面" class="headerlink" title="后台方面"></a>后台方面</h3><p>  今天设计正式提出了接下来的Affair项目功能需求，涉及的东西挺多<br>  接下来要做的东西中“较为可行”的 如何授权微信登录 实现点赞 评论（后面两个还行，第一个看下教学吧） 发布任务<br>  最难搞的还是那些逻辑，听得懂但是要写出代码来，毕竟是以前没有做过的things，真实情况也的确是难度很大，开发不完应该是板上钉钉，但是也会拼尽全力去实现的！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前端方面&quot;&gt;&lt;a href=&quot;#前端方面&quot; class=&quot;headerlink&quot; title=&quot;前端方面&quot;&gt;&lt;/a&gt;前端方面&lt;/h3&gt;&lt;p&gt;今天从中午开始就一直在做一个页面，因为是第一次做网页(除教程外的第一个)，遇到了很多很多的问题，我想做熟练了写起代码来应该就
      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="http://yoursite.com/2018/07/21/flex%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/07/21/flex布局/</id>
    <published>2018-07-21T15:47:03.000Z</published>
    <updated>2018-07-22T17:41:05.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="flex由来"><a href="#flex由来" class="headerlink" title="flex由来"></a>flex由来</h3><p>布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。W3C 提出了一种新的方案—-Flex 布局（弹性布局），可以简便、完整、响应式地实现各种页面布</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>任何一个容器都可以指定为 Flex 布局。   display: flex;<br>行内元素也可以使用 Flex 布局。         display: inline-flex;<br>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</p><h3 id="六大属性"><a href="#六大属性" class="headerlink" title="六大属性"></a>六大属性</h3><p>####flex-direction(决定主轴的方向)<br>row（默认值）：主轴为水平方向，起点在左端。<br>row-reverse：<br>column：<br>column-reverse:</p><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><blockquote><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p></blockquote><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>nowrap（默认）：不换行。<br>wrap：换行，第一行在上<br>wrap-reverse：换行，第一行在下方。</p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>属性定义了项目在主轴上的对齐方式。<br>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目<em>之间</em>的间隔都相等。<br>space-around：每个项目<em>两侧</em>的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>属性定义项目在交叉轴上如何对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度<br>flex-start：交叉轴的起点对齐。<br>flex-end：交叉轴的终点对齐。<br>center：交叉轴的中点对齐。<br>baseline: 项目的第一行文字的基线对齐。</p><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br>stretch（默认值）：轴线占满整个交叉轴。<br>flex-start：与交叉轴的起点对齐。<br>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</p><h3 id="对于项目item使用的属性"><a href="#对于项目item使用的属性" class="headerlink" title="对于项目item使用的属性"></a>对于项目item使用的属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>属性定义项目的放大比例，默认为0，意思是如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>在分配多余空间之前项目占据的主轴空多大。以如果设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>属性是前面三个的简写，默认0 1 auto<br>两个快捷方式 auto（1 1 auto）<br>                       none （0 0 auto）</p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;flex由来&quot;&gt;&lt;a href=&quot;#flex由来&quot; class=&quot;headerlink&quot; title=&quot;flex由来&quot;&gt;&lt;/a&gt;flex由来&lt;/h3&gt;&lt;p&gt;布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>后台进化史之第七天</title>
    <link href="http://yoursite.com/2018/07/19/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E7%AC%AC%E4%B8%83%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/07/19/后台进化史之第七天/</id>
    <published>2018-07-19T15:53:19.000Z</published>
    <updated>2018-07-19T16:13:08.142Z</updated>
    
    <content type="html"><![CDATA[<p>##网络层相关<br>网关实质上是一个网络通向其他网络的IP地址<br>主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机（如附图所示）。网络A向网络B转发数据包的过程</p><p>##继续学习CSS<br>看了瀚程给大爷的新时代修BUG</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##网络层相关&lt;br&gt;网关实质上是一个网络通向其他网络的IP地址&lt;br&gt;主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>后台进化史之第六天</title>
    <link href="http://yoursite.com/2018/07/18/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/07/18/后台进化史之第六天/</id>
    <published>2018-07-18T15:30:53.000Z</published>
    <updated>2018-07-18T17:32:53.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>express xx生成一个express文件，进入bin，npm start 等同于node ./bin/www 运行node服务</p><p>package.json下列出的模块表明是运行所需要的，npm install 会自行安装。便于客户端执行服务。</p><p>jade模板引擎，在express开发中有粗略看过，当初还没学前端htmlcss基本懵逼，现在看好多了。模板引擎是用来简化html代码的，晚点再看看。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.post(<span class="string">'*'</span>,<span class="function"><span class="keyword">function</span><span class="params">(req,res,next)</span></span>&#123;</span><br><span class="line">   xxxxxx;</span><br><span class="line">   <span class="built_in">next</span>()；</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>路径如果设定是*，表明所有的请求都要经过这个路由，再执行next方法，比如用来检测用户在一个页面停留的时间是否过长，从而判断登录状态。</p><h2 id="继续学css"><a href="#继续学css" class="headerlink" title="继续学css"></a>继续学css</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;express&quot;&gt;&lt;a href=&quot;#express&quot; class=&quot;headerlink&quot; title=&quot;express&quot;&gt;&lt;/a&gt;express&lt;/h2&gt;&lt;p&gt;express xx生成一个express文件，进入bin，npm start 等同于node ./
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>后台进化史之第五天</title>
    <link href="http://yoursite.com/2018/07/17/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/07/17/后台进化史之第五天/</id>
    <published>2018-07-17T14:16:23.000Z</published>
    <updated>2018-07-17T15:31:33.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p>早上瀚程扔了一个王福朋的博客，里面讲了很多有关Js cSS的东西，这个人真牛逼。早上讲了原型链，this，执行上下文等，结合王福朋的博客看了一点。</p><ul><li>对象都是通过函数来创建的，但是函数又是一种对象（万物皆对象）</li><li>每一个函数都有一个prototype属性，这个属性的值是一个对象（属性集合），默认的只有一个构造器函数constructor，指向函数本身。</li><li>每个对象都有一个隐藏的属性——“<strong>proto</strong>”，这个属性引用了创建这个对象的函数的prototype。即：fn.<strong>proto</strong> === Fn.prototype</li></ul><blockquote><p>下面是一个经典的例子<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="keyword">Fn</span><span class="params">()</span> &#123; &#125;</span></span><br><span class="line"><span class="function">        <span class="keyword">Fn</span>.prototype.<span class="title">name</span> = '王福朋'</span>;</span><br><span class="line">        <span class="function"><span class="keyword">Fn</span>.prototype.<span class="title">getYear</span> = function <span class="params">()</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="keyword">return</span> <span class="number">1988</span></span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var <span class="function"><span class="keyword">fn</span> = <span class="keyword">new</span> <span class="keyword">Fn</span><span class="params">()</span></span>;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="function"><span class="keyword">fn</span>.name)</span>;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="function"><span class="keyword">fn</span>.getYear<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<strong>proto</strong>这条链向上找，这就是原型链。</p></li><li><p>由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。</p></li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>通俗说法在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。</p><h3 id="this的取值"><a href="#this的取值" class="headerlink" title="this的取值"></a>this的取值</h3><p><em><font color="green">在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了</font></em><br>分为四种情况，震惊，这么详细<br>1、 构造函数中this指向new出来的对象<br>2、 函数作为对象的一个属性，并且被调用,this指向这个对象，如果作为属性但是不被调用，还是指向window<br>3、 函数用call或者apply调用，this的值取传入的参数（对象）的值<br>4、 全局下this指向window，普通函数调用的时候也是指向window</p><h2 id="html与css"><a href="#html与css" class="headerlink" title="html与css"></a>html与css</h2><p>今天大部分时间还是在学html与css，昨天学的是node的express框架。<br>常用的html元素，一些css样式写法，大家都懂的没什么好说</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;js&quot;&gt;&lt;a href=&quot;#js&quot; class=&quot;headerlink&quot; title=&quot;js&quot;&gt;&lt;/a&gt;js&lt;/h2&gt;&lt;p&gt;早上瀚程扔了一个王福朋的博客，里面讲了很多有关Js cSS的东西，这个人真牛逼。早上讲了原型链，this，执行上下文等，结合王福朋的博客看了
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>后台进化史之第四天</title>
    <link href="http://yoursite.com/2018/07/16/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/07/16/后台进化史之第四天/</id>
    <published>2018-07-16T14:25:56.000Z</published>
    <updated>2018-07-16T16:30:52.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><h4 id="了解了使用express框架如何处理表单请求"><a href="#了解了使用express框架如何处理表单请求" class="headerlink" title="了解了使用express框架如何处理表单请求"></a><font color="cray">了解了使用express框架如何处理表单请求</font></h4><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>当表单被提交（通过浏览器或AJAX）时，必须被编码。如果没有明确地指定编码，则默认为application/x-wwwform-urlencoded。<br>如果需要上传文件，使用multipart/form-data编码类型（并不被建议使用）。</p><h5 id="处理表单的不同方式"><a href="#处理表单的不同方式" class="headerlink" title="处理表单的不同方式"></a>处理表单的不同方式</h5><p>如果method=”POST”m展示表单和处理表单可以用同一个路由，因为展示只需要get请求，而处理一般是post请求，使用同一个路由是可以区分的，这一点我当初在做考核的时候倒是没有考虑到。</p><h5 id="处理完后如何响应"><a href="#处理完后如何响应" class="headerlink" title="处理完后如何响应"></a>处理完后如何响应</h5><p>1、 直接响应html，就是直接扔一个html<br>2、 303重定向 { 重定向到某一个特殊的界面，跳转成功应该去哪里，404定制界面等}</p><h5 id="表单域的获取"><a href="#表单域的获取" class="headerlink" title="表单域的获取"></a>表单域的获取</h5><p>1、对于GET请求 域放在req,query<br>2、对于POST请求，域放在req.body中，需要引入一个body-parser 很常用的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;express&quot;&gt;&lt;a href=&quot;#express&quot; class=&quot;headerlink&quot; title=&quot;express&quot;&gt;&lt;/a&gt;express&lt;/h2&gt;&lt;h4 id=&quot;了解了使用express框架如何处理表单请求&quot;&gt;&lt;a href=&quot;#了解了使用expres
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>事件循环机制和几种数组方法</title>
    <link href="http://yoursite.com/2018/07/16/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E5%87%A0%E7%A7%8D%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/16/事件循环机制和几种数组方法/</id>
    <published>2018-07-15T16:00:00.000Z</published>
    <updated>2018-08-19T17:04:31.350Z</updated>
    
    <content type="html"><![CDATA[<font face="STCAIYUN" color="gray" size="6">Everything runs in parallel except your code!</font><h3 id="事件循环（以及异步，回调）"><a href="#事件循环（以及异步，回调）" class="headerlink" title="事件循环（以及异步，回调）"></a>事件循环（以及异步，回调）</h3><p>js 事件轮询机制</p><blockquote><p>在js中同步和异步的任务会分别进入不同的执行场所，同步任务进入主线程异步的进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的Event Loop(事件循环)。<br><img src="/2018/07/16/事件循环机制和几种数组方法/2018041120124254.png" alt="Alt text"></p></blockquote><blockquote><p>但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。<img src="/2018/07/16/事件循环机制和几种数组方法/20180411202638415.png" alt="Alt text"></p></blockquote><p>菠萝说的<br>宏任务一般有：script，setTimeout，setInterval。</p><p>微任务：Promise，process.nextTick。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>记录类型A 表明主机记录指向唯一的IP<br>记录类型CNAME 一个域名指向另一个域名</p><p>买了一个新的域名尝试了将其指向原有的博客域名，一顿操作终于好了<br>缓存真是个奇怪的东西，明明就是ping一样的地址，上一刻和下一刻效果不一样</p><h3 id="添加虚拟主机的常用命令"><a href="#添加虚拟主机的常用命令" class="headerlink" title="添加虚拟主机的常用命令"></a>添加虚拟主机的常用命令</h3><p>lnmp vhost add<br>lnmp vhost list<br>cd /home wwwroot/<br>lnmp list<br>cd 进去 找到index.html，vim模式编辑</p><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><blockquote><p>Post请求体</p><ul><li>常用媒体类型是application/x-www-form-urlencoded</li><li>如果需要上传文件 multipart/form-data</li><li>如果是AJAX请求 application/json</li></ul></blockquote><h3 id="数组操作几种方法-codewar"><a href="#数组操作几种方法-codewar" class="headerlink" title="数组操作几种方法(codewar)"></a>数组操作几种方法(codewar)</h3><blockquote><p>今天做的这道题让我回忆，以及get到了一些或旧或新的方法，这些方法都是挺有用的</p></blockquote><h4 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter()过滤"></a>filter()过滤</h4><p>filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。</p><blockquote><p>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="number">2</span> <span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="number">3</span>     <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</span><br><span class="line"><span class="number">4</span> &#125;);</span><br><span class="line"><span class="number">5</span> r; <span class="comment">// [1, 5, 9, 15]</span></span><br></pre></td></tr></table></figure></p></blockquote><h4 id="split-分隔"><a href="#split-分隔" class="headerlink" title="split()分隔"></a>split()分隔</h4><blockquote><p>分割字符串的方法<br>注意这两个<br>split(“”) 每个元素分隔<br>split(“ “)以空格为分隔符分隔</p></blockquote><h4 id="几种遍历方法"><a href="#几种遍历方法" class="headerlink" title="几种遍历方法"></a>几种遍历方法</h4><blockquote><p>回顾了一下js数组遍历的几种方法<br>1、 普通for循环,最简单的一种，也是使用频率最高的一种，瀚程如是说，的确是最熟悉性能也是挺高</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; arr.<span class="built_in">length</span>; <span class="built_in">j</span>++) &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2、 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>.prototype.<span class="keyword">forEach</span>.call(arr,<span class="function"><span class="keyword">function</span><span class="params">(el)</span></span>&#123;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4、</p><pre><code>for(i in或者of  arr){}</code></pre><p>5、 map遍历</p><pre><code>arr.map(funtion(n){})</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>了解了负载均衡这个概念</p><h2 id="最后附上一道题，有关异步的"><a href="#最后附上一道题，有关异步的" class="headerlink" title="最后附上一道题，有关异步的"></a>最后附上一道题，有关异步的</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>这段代码的运行顺序 2，4，3，1<br>原因就是 然后回到开头的代码。因为settimeout是宏任务，虽然先执行的他，但是他被放到了宏任务的eventqueue里面，然后代码继续往下检查看有没有微任务，检测到Promise的then函数把他放入了微任务序列。等到主线进程的所有代码执行结束后。先从微任务queue里拿回掉函数，然后微任务queue空了后再从宏任务的queue拿函数。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font face=&quot;STCAIYUN&quot; color=&quot;gray&quot; size=&quot;6&quot;&gt;Everything runs in parallel except your code!&lt;/font&gt;



&lt;h3 id=&quot;事件循环（以及异步，回调）&quot;&gt;&lt;a href=&quot;#事件循环（以及
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>http协议</title>
    <link href="http://yoursite.com/2018/07/14/http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/07/14/http协议/</id>
    <published>2018-07-14T15:08:28.000Z</published>
    <updated>2018-08-19T10:14:25.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：建立连接时，客户端发送SYN(同步序列编号)包（syn=j）到服务器<br>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k）<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手<br>完成三次握手，客户端与服务器开始传送数据</p><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h3><p>在响应头里面写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Headers'</span>: <span class="string">'预请求头的名字'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Methods'</span>: <span class="string">'POST,PUT,DELETE'</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Max-age'</span>: <span class="string">'1000（允许跨域的处理的最大期限，在这个时间内再次发起请求不需要验证了，单位是秒）'</span></span><br></pre></td></tr></table></figure></p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>要使用缓存的写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.writeHead(stastus,&#123;</span><br><span class="line"><span class="string">'Cache-Control'</span>: <span class="string">'max-age=2 s-maxage= 20private'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ol><li>expires 指定一个绝对的过期时间，但是如果客户端和服务端时间不同步会导致问题，而且很容易忘记自己配置的过期时间具体是多少</li><li>max-age 浏览器缓存 指定的是从文档被访问后的存活时间，这个时间是相对的</li><li>s-maxage 代理缓存</li><li>存在max-age的时候会覆盖expires,在代理过程中存在s-maxage的时候会覆盖max-age</li><li>加private表明只允许浏览器用缓存，代理服务器不能用;加no-store表明 都不允许使用缓存<br><img src="/2018/07/14/http协议/cache.png" alt=""></li></ol><h3 id="CSP限制"><a href="#CSP限制" class="headerlink" title="CSP限制"></a>CSP限制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Content-Security-Policy'</span>: <span class="string">'default-src http: https:'</span> </span><br><span class="line">**限制跳转的域名</span><br><span class="line"></span><br><span class="line"><span class="string">'Content-Security-Policy'</span>: <span class="string">'default-src \'self\' </span></span><br><span class="line"><span class="string">**限制跳转的只能是内部链接</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'</span>Content-Security-Policy<span class="string">': '</span>script-src \<span class="string">'self\' ; form-action \'self\' </span></span><br><span class="line"><span class="string">**限制js的跳转和表单的提交</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'</span>Content-Security-Policy-Only-Report<span class="string">':'</span>report-uri /repot<span class="string">'</span></span><br><span class="line"><span class="string">只做report的请求，即使资源被限制了不想加载，也会执行代码但浏览器仍然会拦截它，并做一个report</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;三次握手&quot;&gt;&lt;a href=&quot;#三次握手&quot; class=&quot;headerlink&quot; title=&quot;三次握手&quot;&gt;&lt;/a&gt;三次握手&lt;/h3&gt;&lt;p&gt;第一次握手：建立连接时，客户端发送SYN(同步序列编号)包（syn=j）到服务器&lt;br&gt;第二次握手：服务器收到SYN包，必须
      
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>蒲公英俱乐部开张啦</title>
    <link href="http://yoursite.com/2018/07/12/%E8%92%B2%E5%85%AC%E8%8B%B1%E4%BF%B1%E4%B9%90%E9%83%A8%E5%BC%80%E5%BC%A0%E5%95%A6/"/>
    <id>http://yoursite.com/2018/07/12/蒲公英俱乐部开张啦/</id>
    <published>2018-07-12T13:47:41.000Z</published>
    <updated>2018-08-19T09:31:08.102Z</updated>
    
    <content type="html"><![CDATA[<p>蒲公英俱乐部开张第一天<br>安装了putty,phpstudy<br>在阿里云够买了一个学生版服务器<br>学会了git里面多人合作常用流程<br>还有就是，这个假的奥克斯，好热~~~<br><a id="more"></a></p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>虽然以前是在廖雪峰的官网学过git的各种命令，但是时隔有点久也是生疏了，最主要的还是学到了 多人协作常用的命令流程：<br>一个人开仓库，邀请其他伙伴作为开发者参与，其他人clone后再checkout自己的分支，多人协作一般是在自己的分支干活，需要提交的时候是先切换回master,pull一下看看远程库有没有更新信息，然后将自己的分支与master合并(merge)，合并完再push，如果有冲突处理完再push上去。</p><h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p>9.9特惠学生套餐<br>有了自己的云服务器和公网IP47.106.21.195</p><h2 id="putty-lnmp"><a href="#putty-lnmp" class="headerlink" title="putty(lnmp)"></a>putty(lnmp)</h2><p>screen -S xxxx创建窗口(我创建的第一个窗口命名lnmp)<br>screen -ls 查看有哪个窗口<br>screen -r xxxx进入指定窗口</p><p> lnmp一键安装搞定了<br> 然后就可以访问那串IP了 默认是读取index(像豪哥自己那个博客就是放在自己的公网IP下的)<br> 进去index的路径/home wwwroot/  fault/</p><p> mv 移动文件或者改名字<br> 如果是要修改名字的话  mv+原名+新名<br> vim 创建编辑模式 ，按i进入编辑模式，否则是观察模式，按esc回到观察模式，打一个冒号然后:wq  退出并保存</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;蒲公英俱乐部开张第一天&lt;br&gt;安装了putty,phpstudy&lt;br&gt;在阿里云够买了一个学生版服务器&lt;br&gt;学会了git里面多人合作常用流程&lt;br&gt;还有就是，这个假的奥克斯，好热~~~&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>第二次周结（至6-10）</title>
    <link href="http://yoursite.com/2018/06/10/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%91%A8%E7%BB%93%EF%BC%88%E8%87%B36-10%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/10/第二次周结（至6-10）/</id>
    <published>2018-06-10T11:55:07.000Z</published>
    <updated>2018-08-19T11:03:43.777Z</updated>
    
    <content type="html"><![CDATA[<p> 考试月了，主要是在准备考试，学课程的东西以及准备六级<br> <a id="more"></a></p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p> 给博客换了一个主题，以及加了一个音乐播放器，以前用网易云的时候就发现有个功能“生成外链播放器”<img src="/2018/06/10/第二次周结（至6-10）/外链播放器.png" alt="Alt text"><br> 本来是想放幻界战线的hello world的，挺喜欢这首歌，竟然锁区不给。。虽然可以破解这个版权保护，还是算了，放了个纪念龙族绘梨衣的bgm</p><p> 还改了一些杂七杂八的，干货分享有个steam便利店，可以优惠价买steam的游戏或者低价买随机cdk，贼好的东西，需要的可以看看</p><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><p> 因为忙着课程和四六级的，没有学太多，就把上次留下的小尾巴看了看，几种设计模式和几种继承(后续准备开一个单章处理这个问题)</p><hr><h2 id="课程杂谈？（只是想吐槽下罢了）"><a href="#课程杂谈？（只是想吐槽下罢了）" class="headerlink" title="课程杂谈？（只是想吐槽下罢了）"></a>课程杂谈？（只是想吐槽下罢了）</h2><p> 要六级啦，就试听了一次听力，难得一批，更别说单词还没刷完，周六的模拟考竟然是因为学委打王者入神忘记发通知？？？(excuse me?)</p><p> 高数还行吧，电工依旧要命，这周还没能把时间放在电工上</p><p> 离散的anyview也是要命的，就拿今晚的事，做这一道题，递归运算足足花了我一小时。。C语言和算法退化了啊<br> <img src="/2018/06/10/第二次周结（至6-10）/离散.png" alt="Alt text"><br> 附上做的答案（要不是同学请教，且网上没有这道题的答案，哪用这么受罪TAT）<br> <img src="/2018/06/10/第二次周结（至6-10）/1.png" alt="Alt text"><br> <img src="/2018/06/10/第二次周结（至6-10）/2.png" alt="Alt text"></p><p> 啊~~还是刷刷单词去了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 考试月了，主要是在准备考试，学课程的东西以及准备六级&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>第一次周结（至5-28）</title>
    <link href="http://yoursite.com/2018/05/28/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%91%A8%E7%BB%93%EF%BC%88%E8%87%B35-28%EF%BC%89/"/>
    <id>http://yoursite.com/2018/05/28/第一次周结（至5-28）/</id>
    <published>2018-05-27T17:21:45.000Z</published>
    <updated>2018-08-19T11:00:29.639Z</updated>
    
    <content type="html"><![CDATA[<p>javascript部分<br>express部分<br>git部分<br>博客部分</p><a id="more"></a><h2 id="javascript部分"><a href="#javascript部分" class="headerlink" title="javascript部分"></a>javascript部分</h2><p>大致进度就是红宝书的前五章以及第六章中部了，差点小尾巴，以下是随手列一些<br>1、&lt; script&gt;元素用于在html中插入js的代码，可以用src属性导入内部或外部的的js文件或者url。&lt; script&gt;的代码按照先后顺序解析，一般放在body的内容的后面，用defer async可以就可以实现延迟或异步解析脚本 </p><p>2、在网页在开头写”use strict”进去严格模式<br>3、文档模式分混杂和标准，经常见到这样子的html5标准模式<img src="/2018/05/28/第一次周结（至5-28）/111.png" alt=""></p><p>4一些基础概念在之前学习Node的时候了解过了，操作符，语句也跟C语言差不多我觉得</p><p>5、很多地方对象调用valueof的时候会自动地间接地调用toString(),所以我的理解是valueof返回的是最适合该对象类型的原始值</p><p>6、这个应该不怎么会用到，先记录下来吧infinity*0=NaN infinity/infinity=NaN<br>被除数有限而除数无穷=被除数，被除数无穷 而除数有限=NaN</p><p>7、以前没见过with语句，对同一个对象多个操作的时候可以用with（）{}限制作用域</p><p>8、垃圾收集机制跟java的差不多，js最常用的垃圾收集方式还是标记清除</p><p>9、执行环境，就是作用域，每一门语言这个都是很重要的内容，js没有块级作用域,比如下面这个</p><pre><code class="javascript"><span class="keyword">if</span>(<span class="literal">true</span>){ <span class="keyword">var</span> color=<span class="string">'blue'</span>;}alert(color);</code></pre><p> 在C或C++,JAVA中 color是局部变量，执行完if语句后就销毁了，但是在js中不会，该变量会自动添加到最近的执行环境，这里是全局</p><p>10、几大引用类型Object,Array,Date跟Java类似，学习基本包装类型的时候我竟然想到了java里的自动装箱？差不多吧我觉得；RegExp这个类型之前没接触过，跟正则表达式挂钩..我觉得需要先去学一下正则表达式的种种，做考核的时候有想着给登录注册那里加一个检测机制，判读用户的输入是否符合格式，在这里就用到了正则，当然那个时候个人是粗略看了一下而已</p><h2 id="express部分"><a href="#express部分" class="headerlink" title="express部分"></a>express部分</h2><p>其实一开始是先看着发在群里的那个《node与express开发》，看到handlebars前面那块就先打住了，因为在第四章的时候提到，要么跟随书本的实例手动，要么用官方的存储库，突然就想起git的各种命令。。所以在第六章结束后就去了网上找了资料补了下git和github的内容，还挺详细的。<br>PS：认识一个新的东西QA，质量评价，竟然还有专门的QA职业，大千世界无奇不有</p><h2 id="git部分"><a href="#git部分" class="headerlink" title="git部分"></a>git部分</h2><p>万物起源于init初始化一个本地仓库<br>先git add 再 git commit -m”说明文字”<br>git status查看工作区状态，有什么改动，提交都可以看到，贼方便。<br>git diff可以看到改动了啥<br>git log查看提交历史<br>git reflog查看命令历史，配套使用来确定版本号用来控制版本 参数 –pretty=oneline美观点，跟db的命令find().pretty()一个道理，毕竟丑是原罪<br>git reset –hard xxxx(版本号或者HEAD^) 版本号可以不用打完整的，太长了</p><p>文件已修改，未add到暂存区:git checkout – file可还原<br>文件已修改，并add到暂存区未commit：三种方法，第一种好理解，其余的是从网上找来的另外的方法<img src="/2018/05/28/第一次周结（至5-28）/222.png" alt="Alt text"></p><p>关联github的操作git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:git_username/repository_name.git<br>git push origin master推送最新修改到github</p><p>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xxxx 可以克隆别人的库，我在这周搭博客的时候，有试过切换主题，clone就发挥作用了<br><img src="/2018/05/28/第一次周结（至5-28）/333.png" alt="Alt text"><br>git tag+标签名+版本号 作用就是给版本起个名v1.9v2.0</p><h2 id="博客部分"><a href="#博客部分" class="headerlink" title="博客部分"></a>博客部分</h2><p>最常用的几个命令<br>hexo g  生成静态文件<br>hexo d  deploy我的理解就是部署到github<br>hexo s  本地浏览 localhost:4000<br>hexo n “文章名”   创建一个文档，然后就写写写（要用markdown语法，除了在马克飞象用的那些，应该还有更多可以让文章更漂亮的？）<br><!-- n完要发布三步走 clean g d(试过不用hexo clean，就不能够看到新编辑的文章，不知道为啥一定要先clean？) --></p><p>要做出一个像模像样的博客还有好多东西要搞，慢慢来吧哈哈哈，现在就是一个丑东西，也还没有搞一个域名来绑定，晚点弄一个来van</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript部分&lt;br&gt;express部分&lt;br&gt;git部分&lt;br&gt;博客部分&lt;/p&gt;
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
