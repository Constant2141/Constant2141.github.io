<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星辰在上</title>
  
  <subtitle>万物皆虚，万物皆允</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-18T17:32:53.529Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郑庆义</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>后台进化史之第六天</title>
    <link href="http://yoursite.com/2018/07/18/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/07/18/后台进化史之第六天/</id>
    <published>2018-07-18T15:30:53.000Z</published>
    <updated>2018-07-18T17:32:53.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>express xx生成一个express文件，进入bin，npm start 等同于node ./bin/www 运行node服务</p><p>package.json下列出的模块表明是运行所需要的，npm install 会自行安装。便于客户端执行服务。</p><p>jade模板引擎，在express开发中有粗略看过，当初还没学前端htmlcss基本懵逼，现在看好多了。模板引擎是用来简化html代码的，晚点再看看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.post(&apos;*&apos;,function(req,res,next)&#123;</span><br><span class="line">   xxxxxx;</span><br><span class="line">   next()；</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>路径如果设定是*，表明所有的请求都要经过这个路由，再执行next方法，比如用来检测用户在一个页面停留的时间是否过长，从而判断登录状态。</p><h2 id="继续学css"><a href="#继续学css" class="headerlink" title="继续学css"></a>继续学css</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;express&quot;&gt;&lt;a href=&quot;#express&quot; class=&quot;headerlink&quot; title=&quot;express&quot;&gt;&lt;/a&gt;express&lt;/h2&gt;&lt;p&gt;express xx生成一个express文件，进入bin，npm start 等同于node ./
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>后台进化史之第五天</title>
    <link href="http://yoursite.com/2018/07/17/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E7%AC%AC%E4%BA%94%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/07/17/后台进化史之第五天/</id>
    <published>2018-07-17T14:16:23.000Z</published>
    <updated>2018-07-17T15:31:33.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p>早上瀚程扔了一个王福朋的博客，里面讲了很多有关Js cSS的东西，这个人真牛逼。早上讲了原型链，this，执行上下文等，结合王福朋的博客看了一点。</p><ul><li>对象都是通过函数来创建的，但是函数又是一种对象（万物皆对象）</li><li>每一个函数都有一个prototype属性，这个属性的值是一个对象（属性集合），默认的只有一个构造器函数constructor，指向函数本身。</li><li>每个对象都有一个隐藏的属性——“<strong>proto</strong>”，这个属性引用了创建这个对象的函数的prototype。即：fn.<strong>proto</strong> === Fn.prototype</li></ul><blockquote><p>下面是一个经典的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Fn() &#123; &#125;</span><br><span class="line">        Fn.prototype.name = &apos;王福朋&apos;;</span><br><span class="line">        Fn.prototype.getYear = function () &#123;</span><br><span class="line">            return 1988;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var fn = new Fn();</span><br><span class="line">        console.log(fn.name);</span><br><span class="line">        console.log(fn.getYear());</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<strong>proto</strong>这条链向上找，这就是原型链。</p></li><li><p>由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。</p></li></ul><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>通俗说法在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。</p><h3 id="this的取值"><a href="#this的取值" class="headerlink" title="this的取值"></a>this的取值</h3><p><em><font color="green">在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了</font></em><br>分为四种情况，震惊，这么详细<br>1、 构造函数中this指向new出来的对象<br>2、 函数作为对象的一个属性，并且被调用,this指向这个对象，如果作为属性但是不被调用，还是指向window<br>3、 函数用call或者apply调用，this的值取传入的参数（对象）的值<br>4、 全局下this指向window，普通函数调用的时候也是指向window</p><h2 id="html与css"><a href="#html与css" class="headerlink" title="html与css"></a>html与css</h2><p>今天大部分时间还是在学html与css，昨天学的是node的express框架。<br>常用的html元素，一些css样式写法，大家都懂的没什么好说</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;js&quot;&gt;&lt;a href=&quot;#js&quot; class=&quot;headerlink&quot; title=&quot;js&quot;&gt;&lt;/a&gt;js&lt;/h2&gt;&lt;p&gt;早上瀚程扔了一个王福朋的博客，里面讲了很多有关Js cSS的东西，这个人真牛逼。早上讲了原型链，this，执行上下文等，结合王福朋的博客看了
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>后台进化史之第四天</title>
    <link href="http://yoursite.com/2018/07/16/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E7%AC%AC%E5%9B%9B%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/07/16/后台进化史之第四天/</id>
    <published>2018-07-16T14:25:56.000Z</published>
    <updated>2018-07-16T16:30:52.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><h4 id="了解了使用express框架如何处理表单请求"><a href="#了解了使用express框架如何处理表单请求" class="headerlink" title="了解了使用express框架如何处理表单请求"></a><font color="cray">了解了使用express框架如何处理表单请求</font></h4><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>当表单被提交（通过浏览器或AJAX）时，必须被编码。如果没有明确地指定编码，则默认为application/x-wwwform-urlencoded。<br>如果需要上传文件，使用multipart/form-data编码类型（并不被建议使用）。</p><h5 id="处理表单的不同方式"><a href="#处理表单的不同方式" class="headerlink" title="处理表单的不同方式"></a>处理表单的不同方式</h5><p>如果method=”POST”m展示表单和处理表单可以用同一个路由，因为展示只需要get请求，而处理一般是post请求，使用同一个路由是可以区分的，这一点我当初在做考核的时候倒是没有考虑到。</p><h5 id="处理完后如何响应"><a href="#处理完后如何响应" class="headerlink" title="处理完后如何响应"></a>处理完后如何响应</h5><p>1、 直接响应html，就是直接扔一个html<br>2、 303重定向 { 重定向到某一个特殊的界面，跳转成功应该去哪里，404定制界面等}</p><h5 id="表单域的获取"><a href="#表单域的获取" class="headerlink" title="表单域的获取"></a>表单域的获取</h5><p>1、对于GET请求 域放在req,query<br>2、对于POST请求，域放在req.body中，需要引入一个body-parser 很常用的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;express&quot;&gt;&lt;a href=&quot;#express&quot; class=&quot;headerlink&quot; title=&quot;express&quot;&gt;&lt;/a&gt;express&lt;/h2&gt;&lt;h4 id=&quot;了解了使用express框架如何处理表单请求&quot;&gt;&lt;a href=&quot;#了解了使用expres
      
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>世界杯决赛日</title>
    <link href="http://yoursite.com/2018/07/16/%E4%B8%96%E7%95%8C%E6%9D%AF%E5%86%B3%E8%B5%9B%E6%97%A5/"/>
    <id>http://yoursite.com/2018/07/16/世界杯决赛日/</id>
    <published>2018-07-15T16:00:00.000Z</published>
    <updated>2018-07-16T14:54:19.398Z</updated>
    
    <content type="html"><![CDATA[<p>Everything runs in parallel except your code!</p><h3 id="事件循环（以及异步，回调）"><a href="#事件循环（以及异步，回调）" class="headerlink" title="事件循环（以及异步，回调）"></a>事件循环（以及异步，回调）</h3><p>js 事件轮询机制</p><blockquote><p>在js中同步和异步的任务会分别进入不同的执行场所，同步任务进入主线程异步的进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的Event Loop(事件循环)。<br><img src="/2018/07/16/世界杯决赛日/2018041120124254.png" alt="Alt text"></p></blockquote><blockquote><p>但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。<img src="/2018/07/16/世界杯决赛日/20180411202638415.png" alt="Alt text"></p></blockquote><p>菠萝说的<br>宏任务一般有：script，setTimeout，setInterval。</p><p>微任务：Promise，process.nextTick。</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>记录类型A 表明主机记录指向唯一的IP<br>记录类型CNAME 一个域名指向另一个域名</p><p>买了一个新的域名尝试了将其指向原有的博客域名，一顿操作终于好了<br>缓存真是个奇怪的东西，明明就是ping一样的地址，上一刻和下一刻效果不一样</p><h3 id="添加虚拟主机的常用命令"><a href="#添加虚拟主机的常用命令" class="headerlink" title="添加虚拟主机的常用命令"></a>添加虚拟主机的常用命令</h3><p>lnmp vhost add<br>lnmp vhost list<br>cd /home wwwroot/<br>lnmp list<br>cd 进去 找到index.html，vim模式编辑</p><h3 id="express"><a href="#express" class="headerlink" title="express"></a>express</h3><blockquote><p>Post请求体</p><ul><li>常用媒体类型是application/x-www-form-urlencoded</li><li>如果需要上传文件 multipart/form-data</li><li>如果是AJAX请求 application/json</li></ul></blockquote><h3 id="codewar"><a href="#codewar" class="headerlink" title="codewar"></a>codewar</h3><blockquote><p>今天做的这道题让我回忆，以及get到了一些或旧或新的方法，这些方法都是挺有用的<br>filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。<br>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 4, 5, 6, 9, 10, 15];</span><br><span class="line">2 var r = arr.filter(function (x) &#123;</span><br><span class="line">3     return x % 2 !== 0;</span><br><span class="line">4 &#125;);</span><br><span class="line">5 r; // [1, 5, 9, 15]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>分割字符串的方法<br>split（“”） 注意参数的分隔符 </p></blockquote><p>回顾了一下js数组遍历的几种方法<br>1、 普通for循环,最简单的一种，也是使用频率最高的一种，瀚程如是说，的确是最熟悉性能也是挺高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2、 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function(e)&#123;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.forEach.call(arr,function(el)&#123;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4、</p><pre><code>for(i in或者of  arr){}</code></pre><p>5、 map遍历</p><pre><code>arr.map(funtion(n){})</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>了解了负载均衡这个概念</p><h2 id="最后附上一道题，有关异步的"><a href="#最后附上一道题，有关异步的" class="headerlink" title="最后附上一道题，有关异步的"></a>最后附上一道题，有关异步的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;1&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(&apos;3&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">console.log(&apos;4&apos;);</span><br></pre></td></tr></table></figure><blockquote><p>这段代码的运行顺序 2，4，3，1<br>原因就是 然后回到开头的代码。因为settimeout是宏任务，虽然先执行的他，但是他被放到了宏任务的eventqueue里面，然后代码继续往下检查看有没有微任务，检测到Promise的then函数把他放入了微任务序列。等到主线进程的所有代码执行结束后。先从微任务queue里拿回掉函数，然后微任务queue空了后再从宏任务的queue拿函数。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Everything runs in parallel except your code!&lt;/p&gt;
&lt;h3 id=&quot;事件循环（以及异步，回调）&quot;&gt;&lt;a href=&quot;#事件循环（以及异步，回调）&quot; class=&quot;headerlink&quot; title=&quot;事件循环（以及异步，回调）
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>有关http协议</title>
    <link href="http://yoursite.com/2018/07/14/%E6%9C%89%E5%85%B3http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/07/14/有关http协议/</id>
    <published>2018-07-14T15:08:28.000Z</published>
    <updated>2018-07-15T17:45:04.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：建立连接时，客户端发送SYN(同步序列编号)包（syn=j）到服务器<br>第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k）<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手<br>完成三次握手，客户端与服务器开始传送数据</p><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h3><p>在头里面写<br><code>&#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;</code><br><code>&#39;Access-Control-Allow-Headers&#39;: &#39;预请求头的名字&#39;</code><br><code>&#39;Access-Control-Allow-Methods&#39;: &#39;POST,PUT,DELETE&#39;</code><br><code>&#39;Access-Control-Allow-Max-age&#39;: &#39;1000（允许跨域的处理的最大期限，在这个时间内再次发起请求不需要验证了，单位是秒）&#39;</code> </p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>要使用缓存的写法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.writeHead(stastus,&#123;</span><br><span class="line">&apos;Cache-Control&apos;: &apos;max-age=2 s-maxage= 20private&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ol><li>expires 指定一个绝对的过期时间，但是如果客户端和服务端时间不同步会导致问题，而且很容易忘记自己配置的过期时间具体是多少</li><li>max-age 浏览器缓存 指定的是从文档被访问后的存活时间，这个时间是相对的</li><li>s-maxage 代理缓存</li><li>存在max-age的时候会覆盖expires,在代理过程中存在s-maxage的时候会覆盖max-age</li><li>加private表明只允许浏览器用缓存，代理服务器不能用;加no-store表明 都不允许使用缓存<br><img src="/2018/07/14/有关http协议/cache.png" alt=""></li></ol><h3 id="CSP限制"><a href="#CSP限制" class="headerlink" title="CSP限制"></a>CSP限制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&apos;Content-Security-Policy&apos;: &apos;default-src http: https:&apos; </span><br><span class="line">**限制跳转的域名</span><br><span class="line"></span><br><span class="line">&apos;Content-Security-Policy&apos;: &apos;default-src \&apos;self\&apos; </span><br><span class="line">**限制跳转的只能是内部链接</span><br><span class="line"></span><br><span class="line">&apos;Content-Security-Policy&apos;: &apos;script-src \&apos;self\&apos; ; form-action \&apos;self\&apos; </span><br><span class="line">**限制js的跳转和表单的提交</span><br><span class="line"></span><br><span class="line">&apos;Content-Security-Policy-Only-Report&apos;:&apos;report-uri /repot&apos;</span><br><span class="line">只做report的请求，即使资源被限制了不想加载，也会执行代码但浏览器仍然会拦截它，并做一个report</span><br></pre></td></tr></table></figure><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>特点也是优势：信道复用、分帧传输</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;三次握手&quot;&gt;&lt;a href=&quot;#三次握手&quot; class=&quot;headerlink&quot; title=&quot;三次握手&quot;&gt;&lt;/a&gt;三次握手&lt;/h3&gt;&lt;p&gt;第一次握手：建立连接时，客户端发送SYN(同步序列编号)包（syn=j）到服务器&lt;br&gt;第二次握手：服务器收到SYN包，必须
      
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>开张第一天</title>
    <link href="http://yoursite.com/2018/07/12/%E5%BC%80%E5%BC%A0%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/07/12/开张第一天/</id>
    <published>2018-07-12T13:47:41.000Z</published>
    <updated>2018-07-13T01:36:48.524Z</updated>
    
    <content type="html"><![CDATA[<p>蒲公英俱乐部开张第一天<br>安装了putty,phpstudy<br>买了个阿里云服务器<br>了解了一下常用的多人合作git流程<br>热~~~<br><a id="more"></a></p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>虽然以前是在廖雪峰的官网学过git的各种命令，但是时隔有点久也是生疏了，最主要的还是学到了 多人协作常用的命令流程：<br>一个人开仓库，邀请其他伙伴作为开发者参与，其他人clone后再checkout自己的分支，多人协作一般是在自己的分支干活，需要提交的时候是先切换回master,pull一下看看远程库有没有更新信息，然后将自己的分支与master合并(merge)，合并完再push，如果有冲突处理完再push上去。</p><h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p>9.9特惠学生套餐<br>有了自己的云服务器和公网IP47.106.21.195</p><h2 id="putty-lnmp"><a href="#putty-lnmp" class="headerlink" title="putty(lnmp)"></a>putty(lnmp)</h2><p>screen -S xxxx创建窗口(这么叫？随便了)<br>screen -ls 查看有哪个窗口<br>screen -r xxxx进入指定窗口</p><p> lnmp一键安装搞定了<br> 然后就可以访问那串IP了 默认是读取index(听说以后博客放这里？)<br> 进去index的路径/home wwwroot/  fault/</p><p> mv 移动文件或者改名字 mv 原名 新名<br> vim 创建编辑模式 ，按i进入编辑模式，否则是观察模式，按esc回到观察模式，打一个冒号然后:wq  退出并保存</p><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p>先鸽一天，捋一捋再写</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;蒲公英俱乐部开张第一天&lt;br&gt;安装了putty,phpstudy&lt;br&gt;买了个阿里云服务器&lt;br&gt;了解了一下常用的多人合作git流程&lt;br&gt;热~~~&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>第二次周结（至6-10）</title>
    <link href="http://yoursite.com/2018/06/10/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%91%A8%E7%BB%93%EF%BC%88%E8%87%B36-10%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/10/第二次周结（至6-10）/</id>
    <published>2018-06-10T11:55:07.000Z</published>
    <updated>2018-07-12T16:49:04.074Z</updated>
    
    <content type="html"><![CDATA[<p> 考试月了，主要是在准备考试，学课程的东西以及准备六级<br> <a id="more"></a></p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p> 给博客换了一个主题，以及加了一个音乐播放器，以前用网易云的时候就发现有个功能“生成外链播放器”<img src="/2018/06/10/第二次周结（至6-10）/外链播放器.png" alt="Alt text"><br> 本来是想放幻界战线的hello world的，挺喜欢这首歌，竟然锁区不给。。虽然可以破解这个版权保护，还是算了，放了个纪念龙族绘梨衣的bgm</p><p> 还改了一些杂七杂八的，干货分享有个steam便利店，可以优惠价买steam的游戏或者低价买随机cdk，贼好的东西，需要的可以看看</p><hr><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><p> 因为忙着课程和四六级的，没有学太多，就把上次留下的小尾巴看了看，几种设计模式和几种继承</p><hr><h2 id="课程杂谈？（只是想吐槽下罢了）"><a href="#课程杂谈？（只是想吐槽下罢了）" class="headerlink" title="课程杂谈？（只是想吐槽下罢了）"></a>课程杂谈？（只是想吐槽下罢了）</h2><p> 要六级啦，就试听了一次听力，难得一批，更别说单词还没刷完，现在把晚上的睡前微博改成了睡前单词了，周六的模拟考竟然是因为学委打王者入神忘记发通知？？？(好想打学委）</p><p> 高数还行吧，电工依旧要命，这周还没能把时间放在电工上</p><p> 离散的anyview也是要命的，就拿今晚的事，做这一道题，递归运算足足花了我一小时。。C语言和算法退化了啊<br> <img src="/2018/06/10/第二次周结（至6-10）/离散.png" alt="Alt text"><br> 附上做的答案（要不是同学请教，且网上没有这道题的答案，哪用这么受罪TAT）<br> <img src="/2018/06/10/第二次周结（至6-10）/1.png" alt="Alt text"><br> <img src="/2018/06/10/第二次周结（至6-10）/2.png" alt="Alt text"></p><p> 啊~~还是刷刷单词去了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 考试月了，主要是在准备考试，学课程的东西以及准备六级&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>第一次周结（至5-28）</title>
    <link href="http://yoursite.com/2018/05/28/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%91%A8%E7%BB%93%EF%BC%88%E8%87%B35-28%EF%BC%89/"/>
    <id>http://yoursite.com/2018/05/28/第一次周结（至5-28）/</id>
    <published>2018-05-27T17:21:45.000Z</published>
    <updated>2018-07-12T13:42:13.409Z</updated>
    
    <content type="html"><![CDATA[<p>javascript部分<br>express部分<br>git部分<br>博客部分</p><a id="more"></a><h2 id="javascript部分"><a href="#javascript部分" class="headerlink" title="javascript部分"></a>javascript部分</h2><p>大致进度就是红宝书的前五章以及第六章中部了，差点小尾巴，以下是随手列一些<br>1、&lt; script&gt;元素用于在html中插入js的代码，可以用src属性导入内部或外部的的js文件或者url。&lt; script&gt;的代码按照先后顺序解析，一般放在body的内容的后面，用defer async可以就可以实现延迟或异步解析脚本<br>2、在网页在开头写”use strict”进去严格模式<br>3、文档模式分混杂和标准，经常见到这样子的html5标准模式<img src="/2018/05/28/第一次周结（至5-28）/111.png" alt=""></p><p>4一些基础概念在之前学习Node的时候了解过了，操作符，语句也跟C语言差不多我觉得</p><p>5、很多地方对象调用valueof的时候会自动地间接地调用toString(),所以我的理解是valueof返回的是最适合该对象类型的原始值</p><p>6、这个应该不怎么会用到，先记录下来吧infinity*0=NaN infinity/infinity=NaN<br>被除数有限而除数无穷=被除数，被除数无穷 而除数有限=NaN</p><p>7、以前没见过with语句，对同一个对象多个操作的时候可以用with（）{}限制作用域</p><p>8、垃圾收集机制跟java的差不多，js最常用的垃圾收集方式还是标记清除</p><p>9、执行环境，就是作用域，每一门语言这个都是很重要的内容，js没有块级作用域,比如下面这个</p><pre><code>if(true){ var color=&apos;blue&apos;;}alert(color);</code></pre><p> 在C或C++,JAVA中 color是局部变量，执行完if语句后就销毁了，但是在js中不会，该变量会自动添加到最近的执行环境，这里是全局</p><p>10、几大引用类型Object,Array,Date跟Java类似，学习基本包装类型的时候我竟然想到了java里的自动装箱？差不多吧我觉得；RegExp这个类型之前没接触过，跟正则表达式挂钩..我觉得需要先去学一下正则表达式的种种，做考核的时候有想着给登录注册那里加一个检测机制，判读用户的输入是否符合格式，在这里就用到了正则，当然那个时候个人是粗略看了一下而已</p><h2 id="express部分"><a href="#express部分" class="headerlink" title="express部分"></a>express部分</h2><p>其实一开始是先看着发在群里的那个《node与express开发》，看到handlebars前面那块就先打住了，因为在第四章的时候提到，要么跟随书本的实例手动，要么用官方的存储库，突然就想起git的各种命令。。所以在第六章结束后就去了网上找了资料补了下git和github的内容，还挺详细的。<br>PS：认识一个新的东西QA，质量评价，竟然还有专门的QA职业，大千世界无奇不有</p><h2 id="git部分"><a href="#git部分" class="headerlink" title="git部分"></a>git部分</h2><p>万物起源于init初始化一个本地仓库<br>add 和commit 频繁使用的命令<br>git status查看工作区状态，有什么改动，提交都可以看到，贼方便。<br>git diff可以看到改动了啥<br>git log查看提交历史git reflog查看命令历史，配套使用来确定版本号用来控制版本 参数 –pretty=oneline美观点，跟db的命令find().pretty()一个道理，毕竟丑是原罪<br>git reset –hard xxxx(版本号或者HEAD^) 版本号可以不用打完整的，太长了</p><p>文件已修改，未add到暂存区:git checkout – file可还原<br>文件已修改，并add到暂存区未commit：三种方法，第一种好理解，其余的是从网上找来的另外的方法<img src="/2018/05/28/第一次周结（至5-28）/222.png" alt="Alt text"></p><p>关联github后<br>git push origin master推送最新修改到github<br>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xxxx 可以克隆别人的库，我在这周搭博客的时候，有试过切换主题，clone就发挥作用了<br><img src="/2018/05/28/第一次周结（至5-28）/333.png" alt="Alt text"><br>git tag+标签名+版本号 作用就是给版本起个名v1.9v2.0</p><h2 id="博客部分"><a href="#博客部分" class="headerlink" title="博客部分"></a>博客部分</h2><p>最常用的几个命令<br>hexo g d s  g是生成静态文件，d是deploy我的理解就是推送到github，s是本地浏览<br>hexo n “文章名”   创建一个文档，然后就写写写（notepad要用markdown语法，除了在马克飞象用的那些，应该还有更多可以让文章更漂亮的？）<br>n完要发布三步走 clean g d(试过不用hexo clean，就不能够看到新编辑的文章，不知道为啥一定要先clean？)</p><p>要做出一个像模像样的博客还有好多东西要搞，慢慢来吧哈哈哈，现在就是一个丑东西，也还没有搞一个域名来绑定，晚点弄一个来van</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript部分&lt;br&gt;express部分&lt;br&gt;git部分&lt;br&gt;博客部分&lt;/p&gt;
    
    </summary>
    
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
