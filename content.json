{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index-1.html"}],"posts":[{"title":"10-12笔记","text":"初入工作室——2018-10-12学习笔记 text-indent : 2em; 首行缩进 1em=1*font-size 块级元素独占一行 可以用css改变宽高 而行级元素不能，img是行级块元素 初始化ul标签 list-style: none margin:0 padding:0 body 天生默认 margin:8px 定位复习display:absolute 脱离原来位置进行定位，找最近的有定位的父级，没有则相对文档display:relative 保留原来位置进行定位，相对于自己原来的位置定位一般用relative作参照物 用absolute定位 垂直方向的margin父子嵌套（兄弟结构也会） 取最大的值 这个bug叫做margin塌陷解决方法两个1暴力解法 在父级加一个 border-top:1px solid2使用bfc 但是只是弥补 目前没有一个完美解决的方法 那么如何触发一个盒子的bfc (block format Context),四种方法position:absolutedisplay:inline-blockfloat:left||rightoverflow: hidden 浮动元素产生浮动流，块级元素看不到浮动元素，只有产生了bfc的元素或文本可以看到要取消浮动可以用 伪元素(伪元素天生是行级元素)或bfc 1可以用伪元素清楚浮动 xx::after{ content:””; display:block; clear:both;}2触发bfc原理就是 设了absolute和float后 内部元素会变成inline-block","link":"/2018/10/12/10-12%E7%AC%94%E8%AE%B0/"},{"title":"10_13笔记","text":"初入工作室——2018-10-13学习笔记 单行文本 height和line-height设为一个值实现单行文本居中 文本溢出处理三件套white-space:nowrap;文本溢出不换行overflow:hidden;text-overflow:ellipsis;//省略号 多行文本溢出处理，PC端没有很好的解决方法，手动打点，截断overflow：hidden 使用css添加图片时，如果网络不佳，为了应对浏览器默认加载策略(在网速不好的时候会不加载CSS JS)，这个时候采取两种方法 1、text-indent一定距离让文字跟在图片后，white-space:nowrap,overflow:hidden2、取消图片的height 用padding-top代替 用padding撑开div，再设overflow:hidden","link":"/2018/10/13/10-13%E7%AC%94%E8%AE%B0/"},{"title":"10_14笔记","text":"初入工作室——2018-10-14学习笔记行级元素只能嵌套行级，块级可以嵌套任何，但是有特殊的↓p标签是块级的，但是嵌套了div进去后，p会被切成两半a标签不能嵌套a标签 设了absolute和float后 内部元素会变成inline-block（和手动设置display:inline-block再可以对行级元素设宽高一样 文本类元素一旦里面有了文字，外部文字就会和里面的对齐","link":"/2018/10/14/10-14%E7%AC%94%E8%AE%B0/"},{"title":"第八周学习报告","text":"初入工作室——2018.10.29-11.04学习笔记 JQ把JQ补完了，JQ插件那块了解了下，用起来不复杂，很方便，以下随便提取几点 jQuery 入口函数与 JavaScript 入口函数的区别：jQuery 的入口函数是在 html 所有标签(DOM)都加载之后，就会去执行。 JavaScript 的 window.onload 事件是等到所有内容，包括外部图片之类的文件加载完后，才会执行。引入文件写在head $(‘#p1’).toggle(speed,callback);1.$(selector)选中的元素的个数为n个，则callback函数会执行n次；2.callback函数名后加括号，会立刻执行函数体，而不是等到显示/隐藏完成后才执行；3.callback既可以是函数名，也可以是匿名函数； 闭包这已经是第三次回顾闭包了，第一次是直接学的时候，第二次是看王福朋的博客，第三次是看了成哥的教学 闭包出现的情况：内部函数被保存到外部，产生闭包，导致原有的作用域链不被释放，造成内存泄漏 或者说闭包就是一个函数引用另外一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。这是优点也是缺点，不必要的闭包只会徒增内存消耗 下面是一道见过无数次的陷阱题1234567891011121314function createFunctions(){ var result = new Array(); for (var i=0; i &lt; 10; i++){ result[i] = function(){ return i; }; } return result;}var funcs = createFunctions();for (var i=0; i &lt; funcs.length; i++){ console.log(funcs[i]());} 输出结果大家都知道了是10个10，具体来讲陷阱就是：函数带()才是执行函数！ 单纯的一句 var f = function() { alert(‘ABC’); }; 是不会弹窗的，后面接一句 f(); 才会执行函数内部的代码。 有关eval()这个函数这个函数见过几次，虽然按道理不常用，但是还是查了一下 1eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。 2eval()解析JSON字符串为函数- 为什么要 eval这里要添加 “(“(“+data+”)”);//”呢？ 原因在于：eval本身的问题。 由于json是以”{}”的方式来开始以及结束的，在JS中，它会被当成一个语句块来处理，所以必须强制性的将它转换成一种表达式。 加上圆括号的目的是迫使eval函数在处理JavaScript代码的时候强制将 括号内的表达式（expression）转化为对象，而不是作为语 句（statement）来执行。举一个例子，例如对象字面量{}，如若不加外层的括号，那么eval会将大括号识别为JavaScript代码块的开始 和结束标记，那么{}将会被认为是执行了一句空语句。所以下面两个执行结果是不同的：12alert(eval(&quot;{}&quot;); // return undefinedalert(eval(&quot;({})&quot;);// return object[Object] 正则去除中文有人突然问到的，看看 验证中文^[\\u4e00-\\u9fa5]+$ 验证字母^[a-zA-Z]+$ 验证数字^[0-9]+$ 中文，字母，数字组成的字符串，不要求三者同时出现^[a-zA-Z0-9\\u4e00-\\u9fa5]+$ \\u4e00-\\u9fa5这两个unicode值正好是Unicode表中的汉字的头和尾。","link":"/2018/10/30/10.29-11.4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Affair开发初步想法","text":"今天学到的和初步想法 有关如何判断登录状态的简单想法一个鉴定函数判断是不是原来的用户（密码错误，全错等）写一个islogined函数 用来判断是否登录状态，调用到authenticate，因为参数取的是req.cookie.如果cookie过时了就空，以此返回不同的值 get到的新知识app.use(‘/‘, users); 这样子写是将users下所有中间件启动 app.get(env) === development 与 process.env.NODE_ENV === ‘development’ 的区别app.get(env)获取的是env的值；process.env.NODE_ENV获取的是 env上面NODE_ENV的值；这两行代码在express中都有出现，意思；还有就是 我们平时写代码一般都是 本地用开发版本；线上用生产版本本地开发版本默认 app.get(env) = development；线上生产版本的环境设置的就是app.get(env) = production; crypto最简单的用法1234const crypto = require('crypto')var hash=crypto.createHash('md5')调用加密算法，常用md5hash.update(userName+pwd)return hash.digest('hex')十六进制 正文：构想（跟咕咕咕的交流过程中随笔）(旁人看不懂滴)稍微理一下思路 123456789101112131415161718192021222324252627282930post(,fun{reddot fn})reddot fn{}------------------评论{}-----------------user schema{头像:ID:}event schema{发布id::涉及id：[ ]标题：状态：[1 2 3]}comment {id:content:date{ var time=new Date( ) time.toString}} 创建小组的功能，设计说不需要做了，倒是省了很多事，不过我想真的做出来后，之后的之后也许会继续完善最大的难题是如何做到微信授权登录，获取微信用户的信息。尝试了putty配置，ngrok生成外网域名然后内网映射过去，查了资料，如何内网映射外网，内网穿透，最后发现貌似不需要内网穿透？？！！接下来先把能做的逻辑写出来，以及等一波菠萝的教学有关于微信授权的技能","link":"/2018/07/24/Affair%E5%BC%80%E5%8F%91%E5%88%9D%E6%AD%A5%E6%83%B3%E6%B3%95/"},{"title":"ES6","text":"稍微总结一下ES6新语法特性 模块化引入12345import * as name from &quot;xxx&quot; //通配符引入所有export的变量， as作用是重命名import {a,b,c} from &quot;xxx&quot; //引入指定的变量import x from &quot;&quot;//没有用*或者{}的，这样写会引入默认export defaultimport &quot;./1.jpg&quot;//模块也可以是图片，js文件，这样直接引入模块的代码，不引入内部成员let promise = import(&quot;xxx&quot;) //也支持异步引入，一定要绝对路径，在编译的时候会生成异步的模块，前面带有数字那些文件 解构赋值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//...展开运算符，把剩余的变量放在一个数组里，只能用于剩下的部分，一直到最后，不可放在中间{ let a,b,rest; [a,b,...rest]=[1,2,3,4,5,6]; console.log(a,b,rest);}//运用解构赋值，快速交换两个数{ let a=1; let b=2; [a,b]=[b,a]; console.log(a,b);}{//接受函数返回值 function f(){ return [1,2] } let a,b; [a,b]=f(); console.log(a,b);}{//选择性接受,用逗号跳过 function f(){ return [1,2,3,4,5] } let a,b,c; [a,,,b]=f(); console.log(a,b);//打印出来是 1,4}{//只取第一个元素，剩下的存进数组 function f(){ return [1,2,3,4,5] } let a,b,c; [a,,...b]=f(); console.log(a,b); }/**对象解构*/ {//前后端交互时，key值一样可以解构出value值 let metaData={ title:'abc', test:[{ title:'test', desc:'description' }] } let {title:esTitle,test:[{title:cnTitle}]}=metaData; console.log(esTitle,cnTitle);}","link":"/2019/03/29/ES6/"},{"title":"Mongo","text":"介绍Mongo相比传统的关系型数据库具有的优点，然后介绍适合Mongo的应用场景。 何谓MongoDBMongoDB是一款广受欢迎的文档型数据库，数据以BSON（一种类JSON的二进制形式）的格式存储 对比传统关系型DB优点对比传统的关系型数据库，MongoDB有很多独有的优势，比如： schema-free，灵活易用的文档模型 原生分布式支持带来良好的扩展性，支持海量数据的存储 强大的索引支持，支持多种索引类型，如TTL、文本、地理位置等等 JSON 格式存储最接近真实对象模型，对开发者友好，方便快速开发迭代 应用场景游戏、UGC、电商、物联网、直播等，支撑了很多核心的业务数据存储 UGC用户生成内容 数据由用户产生，结构多变 数据结构可能是非结构化的，传统关系型数据库需要事先定义好表结构，无法适应这种场景，就算可以支持，增删字段也是麻烦的，MongoDB没有表结构 海量数据存储 如今单个应用的数据存储已经可以达到TB，甚至PB级别，MongoDB天然支持分布式部署，通过分片集群，将数据分布到不同分片，实现海量存储 需要二级索引，按照多个维度查询展示 MongoDB支持多种索引类型，可以对各个字段建立二级索引，能够高效的对各个维度进行查询展示 性能、可用性、数据安全的一个综合考虑 多副本保证数据安全，完善的故障恢复机制，灵活的数据一致性读写接口 游戏 对复杂结构友好（支持Document，自由模式） 游戏的迭代速度很快，装备、属性等字段变更非常频繁，且玩家数据存在频繁的联动与刷新，数据结构极其复杂。使用 MongoDB 存储游戏用户信息、装备、积分等时，会直接以内嵌文档的形式存储，无需进行复杂的模式设计。得益于MongoDB的BSON的文档存储模型，MongoDB具备了多形性和动态性，多形性表示同一个集合包含不同字段的文档对象，这意味着插入一条数据结构更新后的记录，动态性意味着动态增加、修改字段无需停止数据库服务。这种no-schema模式大大免去了变更表结构的痛苦，大幅度缩短游戏版本的迭代周期。 高性能（支持高可用） 延迟高于几百毫秒之后玩家体验会急剧降低；且游戏业务的用户量存在明显的高低峰期。高峰期对数据库的并发能力和QPS有较高要求。 可扩展性（支持Sharding，可扩展） 随着游戏的发展，玩家数量越来越多，或者在某些运营活动的短时间内，用户量暴增。MongoDB本身支持副本集的纵向扩展，通过多个节点的方式，大大提升集群的读能力，通过分片集群的横向扩展，将数据通过片键存储在多台物理机上，实现存储容量线性快速扩展的目的 什么样的场景适合用MongoDB 业务不是非得用到关系型数据库的一些特性（如事务、join等），大多数情况都可以选择MongoDB，当然MongoDB4.0也支持事务了 业务没有固定的数据模型，数据格式变动频繁 需要支持海量数据（TB、PB级别）存储 对性能和延时有较高要求，例如ms级别 游戏一般会考虑Mysql或tcaplus或MongoDB的其中一种，选用MongoDB的大都是代理类业务。一般还是用前两个多 游戏数据库（TcaplusDB）是腾讯自研的，专为游戏设计的分布式非关系型数据存储服务。","link":"/2020/09/23/MongoDB/"},{"title":"Ajax|fetch|Websocket","text":"常见的三种前端发送请求的方式，介绍其使用方法和相关要点。 AjaxAJAX状态值与状态码区别 AJAX状态值是指，运行AJAX所经历过的几种状态，无论访问是否成功都将响应的步骤，可以理解成为AJAX运行步骤。如：正在发送，正在响应等，由AJAX对象与服务器交互时所得；使用“ajax.readyState”获得。（由数字1~4单位数字组成） AJAX状态码是指，无论AJAX访问是否成功，由HTTP协议根据所提交的信息，服务器所返回的HTTP头信息代码，该信息使用“ajax.status”所获得；（由数字1XX,2XX三位数字组成，详细查看RFC）这就是我们在使用AJAX时为什么采用下面的方式判断所获得的信息是否正确的原因。 Ajax写法12345678910111213141516//举个例子,原生写法//如果是post请求，json数据写在send() let ajax=new XMLHttpRequest(); ajax.open('GET', 'http://localhost:8080/a', true); ajax.send(); ajax.onreadystatechange=function (){ if(ajax.readyState==4){ if(ajax.status&gt;=200 &amp;&amp; ajax.status&lt;300 || ajax.status==304){ alert('成功'); let json=JSON.parse(ajax.responseText); console.log(json); }else{ alert('失败'); } } }; 123456789101112131415//JQ的写法//url,type,data必备，dataType默认是json，//如果是发送jsonp数据，额外加一个jsonp:&quot;cb&quot;，值是回调函数的名字// $.ajax({ url:&quot;http://xxxx&quot;, type:'post' data:{wd:'xxx'}, dataType:'text/json/jsonp', jsonp:'cb' }).then(({s}) =&gt; { //成功执行函数 } , res =&gt;{ //失败执行函数 }) AJAX运行步骤与状态值说明 在AJAX实际运行当中，对于访问XMLHttpRequest（XHR）时并不是一次完成的，而是分别经历了多种状态后取得的结果，对于这种状态在AJAX中共有5种，分别是。 0 - (未初始化)还没有调用send()方法 1 - (载入)已调用send()方法，正在发送请求 2 - (载入完成)send()方法执行完成， 3 - (交互)正在解析响应内容 4 - (完成)响应内容解析完成，可以在客户端调用了对于上面的状态，其中“0”状态是在定义后自动具有的状态值，而对于成功访问的状态（得到信息）我们大多数采用“4”进行判断。 AJAX状态码(经常说的服务器status)说明 1**：请求收到，继续处理 2**：操作成功收到，分析、接受 3**：完成此请求必须进一步处理 4**：请求包含一个错误语法或不能完成 5**：服务器执行一个完全有效请求失败 100——客户必须继续发出请求 fetch使用1、 先获取 let res = await fetch(‘xxxx.jpg’)2、 再解析 await res.text()/json()/blob()123456789101112//一个栗子//如果是fetch一个二进制文件，res.blob()之后要用 URL.createObjectURL生成一个url才能用window.onload= function () { let oBtn = document.getElementById('btn1'); let img1 = document.getElementById('img1') oBtn.onclick = async function(){ let res = await fetch('./1.jpg') let data = await res.blob(res) let url = URL.createObjectURL(data) img1.src = url; } } Ajax2.0主要是formdata的使用12345678910111213141516171819202122231、//原生js获取表单元素传入 let oForm=document.querySelector('#form1');let formdata=new FormData(oForm);2、 //jq获取表单元素传入 $('#form1').on('submit', function (){ let formdata=new FormData(this); $.ajax({ url: this.action, type: this.method, data: formdata, processData: false,//取消jq默认的数据格式转换 contentType: false }).then(res=&gt;{ alert('成功'); }, res=&gt;{ alert('失败'); });3、//生成一个空的FormData对象,用append('key','value')let formdata = new FormData();formdata.append('xxx',xxxx) Websocket使用socket.io库实现简单的连接12345678910111213141516171819//服务端const http=require('http');const io=require('socket.io');//1.建立普通httplet server=http.createServer((req, res)=&gt;{});server.listen(8080);//2.建立wslet wsServer=io.listen(server);wsServer.on('connection', sock=&gt;{ //sock.emit('name', 数据) //sock.on('name', function (数据){}); setInterval(function (){ sock.emit('timer', new Date().getTime()); }, 1000);}); 1234567891011121314151617181920//客户端&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;http://localhost:8080/socket.io/socket.io.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script&gt; let sock=io.connect('ws://localhost:8080/'); sock.on('timer', time=&gt;{ console.slog(time); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; JSONPJSON的产生ajax请求会有跨域的问题，而web页面调用js文件不存在跨域问题，并且带有src属性的标签具有跨域能力。于是就想到了在获取服务端数据的时候，服务端把要返回的数据放在一个js格式的文件里面，客户端调用恰巧JSON这种字符串数据格式不仅常用来描述数据，而且被js原生支持于是最后的方案就是客户端调用服务端的JSON文件，服务器要动态生成JSON文件才能把客户端需要的数据装入这种方式就是JSONP，一种非正式的传输协议1234567891011121314151617181920212223242526272829客户端html代码&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data){ alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。'); }; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;; // 创建script标签，设置其属性 var script = document.createElement('script'); script.setAttribute('src', url); // 把script标签加入head，此时调用开始 document.getElementsByTagName('head')[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt;服务端对应文件有一个同名的方法,需要返回的数据作为该方法参数填进来flightHandler({ &quot;code&quot;: &quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5});如果用jq实现，上文jq章节也有简单提到特殊的参数jsonp，再举个栗子 12345678910111213$.ajax({ type: &quot;get&quot;, async: false, url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据 success: function(json){ alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。'); }, error: function(){ alert('fail');","link":"/2019/04/03/ajax-fetch-websocket/"},{"title":"crossorigin和integrity","text":"一次偶然不小心点到查看github某个网址的源代码时，发现了以前从未见过的html属性crossorigin和integrity 一、view-source协议view-source是一种协议，早期基本上每个浏览器都支持这个协议。后来Microsoft考虑安全性，IE就不再支持此协议。但是这个方法在FireFox和Chrome浏览器都还可以使用。 如果要在IE下查看源代码,只能使用查看中的”查看源代码”命令.。FF、Chrome在在浏览器地址栏中输入view-source: URL 二、link标签的crossorigin、integrity属性1&lt;link crossorigin=&quot;anonymous&quot; media=&quot;all&quot; integrity=&quot;sha512-5Bs4ERl99/u2AUfpOZF2F0cdfNby7+Vd9teUshXUBPo5CjwECR7IAEf+weI/eCk5tF7K1h3O8hd8k0+P/HePeg==&quot; rel=&quot;stylesheet&quot; href=&quot;https://github.githubassets.com/assets/frameworks-e41b3811197df7fbb60147e939917617.css&quot; /&gt; 那么这两个属性意味着什么呢，其实之前没有注意到，有些网站使用CDN资源的时候，都会在\\&lt;link>\\&lt;script>\\&lt;img>属性带上这两个属性。 crossorigin两个属性值这个属性指定了加载资源的时候是否使用CORS。有两个值 anonymous：发起一个跨域请求，请求头带上Origin，但是不会发送任何认证信息(不发送cookie，X.509证书和HTTP基本的认证信息)。如果服务器没有设置Access-Control-Allow-Origin：xxx。这个资源限制使用 use-credentials。发起一个跨域请求，带上认证信息，如果服务器不设置 Access-Control-Allow-Origin:xxx限制使用 不设置这个属性，资源不会使用CORS加载(也就是不发送Origin),如果设置非法值，视为使用了anonymous 应用场景引入跨域的脚本，如果这个脚本有错误，因为浏览器的限制（根本原因是协议的规定），是拿不到错误信息的。就算本地尝试使用 window.onerror 去记录脚本的错误时，跨域脚本的错误只会返回 Script error。 HTML5 新的规定，是可以允许本地获取到跨域脚本的错误信息，但有两个条件：一是跨域脚本的服务器必须设置 Access-Controll-Allow-Origin允许当前域名可以获取错误信息，二是这个 script 标签也必须有crossorigin 属性。 缺陷假如允许本地获取到跨域脚本的错误信息那么，那么我们就可以通过报错信息的不一致，推断出当前访问的用户的使用痕迹；进而可以”精准”推送相关的钓鱼网站给他。 ———————————————— integrity与SRI起源 SRI 是 Subresource Integrity 的缩写，直接翻译就是，子资源完整性 Web 性能优化中很重要的一点是让请求提前结束，让可缓存的资源走 CDN 是最通用的做法。CDN 服务提供商通过分布在各地的节点，让用户从最近的节点加载内容，大幅提升速度。但是 CDN 的安全性一直是一个风险点：对于网站主来说，让请求从第三方服务器经过，由第三方响应，安全方面肯定不如自己服务器可控。 我们知道 CSP的白名单机制可以减小 XSS 风险。但是针对 CDN 内容被篡改而导致的 XSS，CSP 并不能防范，因为网站所使用的 CDN 域名，肯定在 CSP 白名单之中。这时候，SRI 就应运而生了。它通过对资源进行摘要签名，来保证外链资源的完整性 目前支持 SRI 的浏览器有Chrome和FF 使用在link，script，img等标签使用integrity属性 这个属性会启用 SRI 策略，浏览器会对资源进行 CORS 校验，这就要求被请求的资源必须同域，或者配置了 Access-Control-Allow-Origin 响应头。 浏览器到资源内容之后，会使用 integrity 所指定的签名算法计算结果，并与 integrity 提供的摘要签名比对，如果二者不一致，就不会执行这个资源。 作用SRI 的作用是保证页面引入的第三方资源的完整性。在第三方 CDN 服务被入侵或回源被运营商劫持、文件内容被加入恶意代码时，网站如果启用了 SRI 策略，那么在支持 SRI 的浏览器下，被篡改的文件无法执行。 虽然HTTPS 也可以确保传输过程中的数据完整性，但是对于 CDN 服务器被入侵或 HTTP 回源被劫持造成的文件篡改，HTTPS 无济于事，这时 SRI 就可以派上用场，作为补充。 但是，如果网站以及 CDN 都没有使用 HTTPS，运营商可以将外链资源及 HTML 页面本身一起劫持，并将资源内容和页面中的摘要签名同步修改，让 SRI 彻底失效。 缺陷大部分运营商劫持，都是为了插入广告代码。如果网站启用了 SRI，会导致篡改后的整个文件无法执行，这很可能让页面变得完全不可用。 当然，为了提高可用性，也可以增加 fallback 处理。例如，在 CDN 资源被篡改而无法加载时，转为使用本站资源：例如cdn引入JQ库，判断是否引入成功，如果没有就使用自己的资源","link":"/2020/03/13/crossorigin%E5%92%8Cintegrity/"},{"title":"css3动画三属性","text":"把css3里与动画有关的三个常见属性的介绍（transition、transform、animate） CSS3制作动画的几个属性：变形(transform)、转换(transition)和动画(animation)transitiontransition主要包含四个属性值：1、执行变换的属性：transition-property2、变换延续的时间：transition-duration3、延续时间内变换的速率：transition-timing-function4、变换延迟时间：transition-delay. transition-property指定当元素其中一个属性改变时执行transition效果，其主要有以下几个值：none(没有属性改变)；all（所有属性改变）这个也是其默认值；indent（元素属性名） transition=duration默认值0，也就是即时。设一个延续时间单位s或者ms transition-timing-functionease 逐渐变慢linear 匀速ease-in 加速ease-out 减速ease-in-out 先加速后减速cubic-bezier 自定义时间曲线 transition-delay默认值0，也就是即时。设一个延迟时间单位s或者ms 随便一个例子123456a { -moz-transition: all 0.5s ease-in; -webkit-transition: all 0.5s ease-in; -o-transition: all 0.5s ease-in; transition: all 0.5s ease-in;} transform主要包括以下几种：旋转rotate、移动translate、扭曲skew、缩放scale以及矩阵变形matrix有一点要注意的 在这里叠加多个属性是用空格分开而不是逗号 通过指定的角度参数进行2D旋转，设置的是正数为顺时针旋转，负的为逆时针旋转，例如1234transform:rotate(30deg)transform:translateX(100px):transform:skew(30deg,10deg):transform:scale(2,1.5): animate 值 说明 随便备注 animation-name 指定@keyframes的名字 animation-duration 动画指定需要多少秒或毫秒完成 0表示无动画，单位可以设s秒或ms毫秒 animation-timing-function 规定动画的速度曲线 ease-in-out、linear等 animation-delay 规定在动画开始之前的延迟。 默认值是0，立即播放动画，设负值表示跳过-2s animation-iteration-count 定义动画的播放次数。 默认是1，可以设置无限循环infinite animation-direction 动画播放的方向 normal正常播放，alternate正方向轮转，alternate-reverse与前者相反 animation-play-state 动画的状态 可以设running正在播放,pause暂停动画，通常在JS使用该属性object.style.animationPlayState=”paused”来暂停动画。 animation-fill-mode 动画时间外属性 可设none，forwards，backwards，both，默认值none表示动画播完后，恢复到初始状态，forwards当动画播完后，保持@keyframes里最后一帧的属性。backwards表示开始播动画前(也就是delay时间内)，应用@keyframes里第一帧的属性，both表示forwards和backforwards都应用。","link":"/2018/10/21/css3%E5%8A%A8%E7%94%BB%E4%B8%89%E5%B1%9E%E6%80%A7/"},{"title":"Express处理表单浅理解","text":"了解了使用express框架如何处理表单请求 编码当表单被提交（通过浏览器或AJAX）时，必须被编码。如果没有明确地指定编码，则默认为application/x-wwwform-urlencoded。如果需要上传文件，使用multipart/form-data编码类型（并不被建议使用）。 处理表单的不同方式如果method=”POST”m展示表单和处理表单可以用同一个路由，因为展示只需要get请求，而处理一般是post请求，使用同一个路由是可以区分的，这一点我当初在做考核的时候倒是没有考虑到。 处理完后如何响应1、 直接响应html，就是直接扔一个html2、 303重定向 { 重定向到某一个特殊的界面，跳转成功应该去哪里，404定制界面等} 表单域的获取1、对于GET请求 域放在req,query2、对于POST请求，域放在req.body中，需要引入一个body-parser 很常用的","link":"/2018/07/16/express%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95%E6%B5%85%E7%90%86%E8%A7%A3/"},{"title":"flex布局","text":"今天学习了flex布局，这个布局还是挺方便的，不然老是float太多问题了 flex由来布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。W3C 提出了一种新的方案—-Flex 布局（弹性布局），可以简便、完整、响应式地实现各种页面布 基本使用任何一个容器都可以指定为 Flex 布局。 display: flex;行内元素也可以使用 Flex 布局。 display: inline-flex;设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效 六大属性flex-direction(决定主轴的方向)row（默认值）：主轴为水平方向，起点在左端。row-reverse：column：column-reverse: flex-wrap 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 flex-flownowrap（默认）：不换行。wrap：换行，第一行在上wrap-reverse：换行，第一行在下方。 justify-content属性定义了项目在主轴上的对齐方式。flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性定义项目在交叉轴上如何对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。 align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。stretch（默认值）：轴线占满整个交叉轴。flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 对于项目item使用的属性order定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性定义项目的放大比例，默认为0，意思是如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis在分配多余空间之前项目占据的主轴空多大。以如果设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性是前面三个的简写，默认0 1 auto两个快捷方式 auto（1 1 auto） none （0 0 auto） align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto","link":"/2018/07/21/flex%E5%B8%83%E5%B1%80/"},{"title":"git的撤销操作","text":"刚刚在使用git commit之后要push，提示报错，原因就不多说了。特意总结了一下如果要撤销add或者commit操作应该怎么做,当然在git status的时候也会自动提示可以用什么操作(5月28日也有过一次对撤销的小结，当时仅仅是撤销文件的更改) 撤销addgit add 如果添加了错误的文件的话想要撤销 git status 先看一下add 中的文件 git reset HEAD 如果后面什么都不跟的话 就是回到上一次状态 add里面的全部撤销了————–or————— git reset HEAD 就是对某个文件进行撤销了 撤销commit已经commit了但是没有Push,想要撤销commit的内容 找到之前提交的git commit的idgit log找到想要撤销的id git reset –hard id完成撤销,同时将代码恢复到指定 id 对应的版本————–or————— git reset id完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改 撤销文件的修改将本次对文件的所有修改撤销,直接对内容撤销的不是对暂存区 git checkout –","link":"/2018/08/20/git%E7%9A%84%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C/"},{"title":"https协议二次了解","text":"7月14日的时候学习到了http的一些事项，三次握手，跨域，缓存,csp等等，以及https相比http的一些优势，在这里再次深入了解一下https HTTPS的基本概念 HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 大特点也是优势有：数据加密、信道复用、分帧传输 HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 HTTPS和HTTP的区别 1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTPS工作原理 客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。 （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 （3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 （4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 （5）Web服务器利用自己的私钥解密出会话密钥。 （6）Web服务器利用会话密钥加密与客户端之间的通信。 HTTPS缺点 虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的： （1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%； （2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； （3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。 （5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。","link":"/2018/08/19/https%E5%8D%8F%E8%AE%AE%E4%BA%8C%E6%AC%A1%E4%BA%86%E8%A7%A3/"},{"title":"http协议","text":"HTTP的三次握手，CORS跨域处理，CSP（内容安全策略）。 三次握手第一次握手：建立连接时，客户端发送SYN(同步序列编号)包（syn=j）到服务器第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k）第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手完成三次握手，客户端与服务器开始传送数据 CORS跨域在响应头里面写1234'Access-Control-Allow-Origin': '*''Access-Control-Allow-Headers': '预请求头的名字''Access-Control-Allow-Methods': 'POST,PUT,DELETE''Access-Control-Allow-Max-age': '1000（允许跨域的处理的最大期限，在这个时间内再次发起请求不需要验证了，单位是秒）' Cache-Control要使用缓存的写法123response.writeHead(stastus,{'Cache-Control': 'max-age=2 s-maxage= 20private'}) expires 指定一个绝对的过期时间，但是如果客户端和服务端时间不同步会导致问题，而且很容易忘记自己配置的过期时间具体是多少 max-age 浏览器缓存 指定的是从文档被访问后的存活时间，这个时间是相对的 s-maxage 代理缓存 存在max-age的时候会覆盖expires,在代理过程中存在s-maxage的时候会覆盖max-age 加private表明只允许浏览器用缓存，代理服务器不能用;加no-store表明 都不允许使用缓存 CSP限制1234567891011'Content-Security-Policy': 'default-src http: https:' **限制跳转的域名'Content-Security-Policy': 'default-src \\'self\\' **限制跳转的只能是内部链接'Content-Security-Policy': 'script-src \\'self\\' ; form-action \\'self\\' **限制js的跳转和表单的提交'Content-Security-Policy-Only-Report':'report-uri /repot'只做report的请求，即使资源被限制了不想加载，也会执行代码但浏览器仍然会拦截它，并做一个report","link":"/2018/07/14/http%E5%8D%8F%E8%AE%AE/"},{"title":"Koa","text":"在使用Koa框架过程中的一些心得体会和踩坑记录。 ctx里面的常见参数ctx.method/url/path/query/ip throw()assert(!condition,statuscode,xxxxx)会把错误信息暴露在前端，当第一个参数的条件不满足执行后面的 ctx.status 设状态码ctx.redirect 重定向ctx.attachment下载文件ctx.state.变量名 用来设置全局变量 12ctx.status = 301||302ctx.redirect = '/xx.html' 文件的坑使用koa-body 或者koa-better-body 获取上传的文件的坑新版本的koa-body通过ctx.request.files获取上传的文件 。现在用这个旧版本的koa-body通过ctx.request.body.files获取上传的文件 ,史诗巨坑 读文件可以用await-fa模块 koa-better-body还可以用ctx.request.fields获取各种类型的请求参数其中文件的写法式ctx.request.fields.file 等价于 ctx.request.files 能用绝对路径的不要用相对，引入path模块，path.resolve(_dirname,’./xxx’) 中间件的坑使用中间件，一定要写next(),并且next()前面一定要有await()，不然会莫名其妙404 要做集中处理错误信息router.all(‘*’,async(ctx,next)=&gt; { try{}catch{}}) 使用中间件是.use 写规则是.all cookie设置cookiectx.cookies.set(name, value, [options])options里面可以写maxAge 获取cookiectx.cookies.get(‘name’); session12345678910在app.js设置app.keys = ['some secret hurr'];//放置一堆keyconst CONFIG = { key: 'koa:sess', //修改key的名字 maxAge: 86400000, // cookie的过期时间 signed: true, //签名默认true renew: true, //过期自动刷新};app.use(session(CONFIG, app)); //第二个参数是app，注意 设置值 ctx.session.username = “张三”; 获取值 ctx.session.username 允许跨域有专门的中间件，不用写那一串了12var cors = require('koa2-cors');app.use(cors()) gzip压缩页面加快网页的加载速度123456const koa = require('koa');const compress = require('koa-compress');const app = koa()；const options = { threshold: 2048 }; app.use(compress(options)); websock，reg，webpack，es6","link":"/2019/07/17/koa/"},{"title":"linux的vim命令","text":"收集常用的在linux系统上可能会用到的vim命令。 进入vi的命令vi filename :打开或新建文件,并将光标置于第一行首 vi n filename ：打开文件,并将光标置于第n行首 vi filename ：打开文件,并将光标置于一行首 vi /pattern filename：打开文件,并将光标置于第一个与pattern匹配的串处 vi -r filename ：在上次正用vi编辑时发生系统崩溃,恢复filename vi filename....filename ：打开多个文件,依次进行编辑 移动光标类命令h ：光标左移一个字符 l ：光标右移一个字符 space：光标右移一个字符 Backspace：光标左移一个字符 k或Ctrl p：光标上移一行 j或Ctrl n ：光标下移一行 Enter ：光标下移一行 w或W ：光标右移一个字至字首 b或B ：光标左移一个字至字首 e或E ：光标右移一个字至字尾 ) ：光标移至句尾 ( ：光标移至句首 }：光标移至段落开头 {：光标移至段落结尾 nG：光标移至第n行首 n ：光标下移n行 n-：光标上移n行 n$：光标移至第n行尾 H ：光标移至屏幕顶行 M ：光标移至屏幕中间行 L ：光标移至屏幕行 0：（注意是数字零）光标移至当前行首 $：光标移至当前行尾 屏幕翻滚类命令Ctrl u：向文件首翻半屏 Ctrl d：向文件尾翻半屏 Ctrl f：向文件尾翻一屏 Ctrl＋b；向文件首翻一屏 nz：将第n行滚至屏幕顶部,不指定n时将当前行滚至屏幕顶部. 插入文本类命令i ：在光标前 I ：在当前行首 a：光标后 A：在当前行尾 o：在当前行之下新开一行 O：在当前行之上新开一行 r：替换当前字符 R：替换当前字符及其后的字符,直至按ESC键 s：从当前光标位置处开始,以输入的文本替代指定数目的字符 保存命令按ESC键 跳到命令模式，然后： :w 保存文件但不退出vi :w file 将修改另外保存到file中，不退出vi :w! 强制保存，不推出vi :wq 保存文件并退出vi :wq! 强制保存文件，并退出vi q: 不保存文件，退出vi :q! 不保存文件，强制退出vi :e! 放弃所有修改，从上次保存文件开始再编辑","link":"/2018/09/17/linux%E7%9A%84vim%E5%91%BD%E4%BB%A4/"},{"title":"nodemailer使用回顾","text":"在写affair的使用有一个发送邮件的需求，使用到了nodemailer这个库12345678910111213141516171819202122232425262728293031323334var transporter=nodemailer.createTransport({//设置邮件传输 // service: 'qq', service和host二选一，写法不同 host:&quot;smtp.qq.com&quot;, //设置服务，可以换成smtp.163.com secureConnection:true, //是否使用TLS，如果是true端口为465，否则为其他端口或者568 port:465, //SMTP端口 auth:{ user:&quot;706608189@qq.com&quot;, //发送人邮箱 pass:&quot;xxxxxx&quot;//我的授权码czvbqzqd }});var sendEmail = function(mail,msg,cb){ var mailOption={ from:&quot;xxxxxx@qq.com&quot;,//发件人邮箱 to:mail//收件人邮箱，例如req.body.email, subject:&quot;注册校验码&quot;//邮件标题 html: 'msg'//邮件内容 }; transporter.sendMail(mailOption,function(error,info){ cb(error,info); // if(error){ // res.json({code:400}) ;//发送未成功 // return console.info(error); // }else{ // res.json({code:200}) ;//发送成功 // console.info(&quot;Message send&quot;); // } })}module.exports={ sendEmail:sendEmail}//nbywbfdd","link":"/2018/09/17/nodemailer%E4%BD%BF%E7%94%A8%E5%9B%9E%E9%A1%BE/"},{"title":"prototype和和_proto_的区别","text":"proto这个属性的意思是，指向自己的父亲创造自己时用的构造方法。而prototype这个属性的意思就是，我自己创建孩子（创建对象）的时候用的构造方法。 123456function too() { this.t = 0; }var t = new too()console.log(t._proto_)console.log(too.prototype) Function去创造了too这个对象，而用too的too()这个构造方法，去创建了t这个对象，所以关系是function生了too,too生了t 这时用instanceof()来判断，instanceof是比较左侧的proto和右侧的prototype是否相同 123console.log(t instanceof too) //trueconsole.log(too instanceof Function) //trueconsole.log(t instanceof Function) //true","link":"/2019/07/11/prototype%E5%92%8C%E5%92%8C-proto-%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"pscp操作方法概括","text":"pscp为window与Linux之间的文件传输工具，使用和Linux下scp命令相似。———————————————————————————— linux 删除命令删除常用操作 rm -rf 目录名字 -r 向下递归，不管有多少级目录，一并删除 -f 直接强行删除，没有任何提示 注意：使用 rm -rf 的时候一定要小心，Linux没有回收站。 Linux创建命令touch Xxx 创建文件mkdir xxx创建文件夹目录 ECS经过试验如果是删除一个文件 重新上传文件夹后 ECS端的文件还在如果是修改一个文件 重新上传文件夹后 ECS端的文件也会跟着修改 主要是看文件和文件夹的名字 我自己的ECS的MongoDB 所在地 /usr/local/mongodb/bin PSCP我自己的例子123pscp D:gitbook root@47.106.21.195:/home/wwwroot/default/gitbookpscp -r d:aaa root@47.106.21.195:/home -p 拷贝文件的时候保留源文件建立的时间。 -q 执行文件拷贝时，不显示任何提示消息。 -r 拷贝整个目录 -v 拷贝文件时，显示提示信息。","link":"/2018/09/17/pscp%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E6%A6%82%E6%8B%AC/"},{"title":"Token机制","text":"介绍了传统的session认证，token鉴权机制，以及在node中怎么应用JWT。 传统的session认证 HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。 解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。 上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。 但是这种基于session的认证使应用本身很难得扩展，随着不用客户端的增加，独立的服务器已无法承载更多的用户，而这个时候基于session认证应用的问题就会暴露出来 基于token机制的认证使用token机制的身份验证方法，在服务器端不需要存储用户的登录记录。大概的流程： 客户端使用用户名和密码请求登录。 服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个token，然后把这个token发送给客户端。 客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。 客户端每次向服务端发送请求的时候都需要带上服务端发给的token。 服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。 相比于传统sessionid都要存起来，token可以存到数据库中，但是有可能查询token的时间会过长导致token丢失（其实token丢失了再重新认证一个就好，但是别丢太频繁，别让用户没事儿就去认证）。 为了避免查询时间过长，可以将token放到内存中。这样查询速度绝对就不是问题了，也不用太担心占据内存，占不了多少内存的。 JWTJWT由三部分构成 头部（header）载荷（payload）签名（signature）12345header{ 'typ':'JWT', //类型 'alg':'HS256' //加密算法}1234567891011121314payload{ 原有注册声明 iss：jwt签发者 sub：jwt所面向的用户 aud：接收jwt的一方 exp：jwt的过期时间，这个过期时间必须大于签发时间 nbf：定义在什么时间之前，该jwt都是不可用的 iat：jwt的签发时间 jti：jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击 公共的声明可以添加任何的信息，一般添加用户的相关信息 &quot;name&quot; : &quot;beichen&quot; &quot;admin&quot;: true} 1234第三部分signature需要header+payload+secretsecret是密钥，可以是随便打的字符串 (我记得string或者buffer类型？)secret是保存在服务器端的，jwt的签发也是在服务端的，secret就是用来进行jwt的签发和jwt的验证，所以它就是你服务端的私钥，在任何场景都不应该流露出去，一旦客户端得知这个secret，那就意味着客户端可以自我签发jwt了 在node中JWT的应用用本次项目的应用举例 在这个token.js文件里，我是先封装了两个方法，一个用来生成token，一个用来解密1234567891011121314151617const jwt = require('jsonwebtoken');const secret = 'zxc' getToken = (data) =&gt; { return jwt.sign(data, secret, { expiresIn: &quot;168h&quot; });}getVerify = (token) =&gt; { return jwt.verify(token,secret)}module.exports = { getToken, getVerify} 在其他涉及到token的地方，导入上面的js文件后就可以直接调用两个方法 1234567891011121314151617登录时生成token并返回给客户端router.get('/login', function (req, res) { var data = { username : 'testAccount', } var token = jwt.getToken(data) // var username = jwt.getVerify(token).username res.json({ code:200, username:data.username, userphoto:data.userphoto, token }) }); 123456789101112131415var jwt = require('./token');router.post('*', (req, res,next) =&gt; { var token = req.body.token; try { jwt.getVerify(token);//因为是写成同步操作，所以可能出现异常，要自行捕获 } catch (error) { console.log('Token过期') return res.json({ msg: 'Token过期' }) } console.log('Token未过期') return next();})","link":"/2018/07/31/token%E6%9C%BA%E5%88%B6%E4%BA%8C%E6%AC%A1%E5%AD%A6%E4%B9%A0/"},{"title":"ts三体验——装饰器和演算","text":"学习ts的类装饰器。 装饰器运行时间：在定义后直接运行执行顺序：从下到上 类装饰器接受一个参数123function test(target:new(...args:any[]) =&gt; object) {}function test(target:Function) {}返回值类型分两种 void：仅仅运行函数 返回一个新的类：新类替换旧类。利用这个可以给新类extends旧类(target)来增强功能，但是会失去类型检查，尽量不适用 属性装饰器接受两个参数12function d(target: any, key: string) {} 如果是静态属性，表示类本身（构造函数），如果是实例属性，表示类的原型（prototype） 一个string，表示属性的名字 方法装饰器1function test(target: any, key: string, descriptor: PropertyDescriptor) {} 接受三个参数 如果是静态属性，表示类本身（构造函数），如果是实例属性，表示类的原型（prototype） 一个string，表示属性的名字 描述符对象 参数装饰器接受三个参数 如果是静态属性，表示类本身（构造函数），如果是实例属性，表示类的原型（prototype） 方法名称 在参数列表中的索引 自动注入元数据前提条件是：安装reflect-metadata，导入该库，在某个成员添加了元数据，并启动了emitDecoratorMetadata在编译结果中，约束的类型会作为元数据加入，这样类型检查有机会在与运行时进行 工具库reflect-metadata作用:保存元数据使用方法：安装后，import “reflect-meatdata”,就可以使用全局变量 在需要装饰的地方用 @Reflect.metadata(Key, Value) 要获取定义过的元数据，Reflect.getMetadata(Key, target,prop?) 判断是否具有某个元数据Reflect.hasMetadata(Key, target, prop?); 直接定义元数据Reflect.defineMetadata(Key, Value, target，prop?);class-validator123456789101112131415161718192021import &quot;reflect-metadata&quot;import{ IsNotEmpty, validate, MinLength, MaxLength }from &quot;class-validator&quot;class RegUser{ @IsNotEmpty({message:&quot;账号不能为空&quot;}) @MinLength(5,{message:&quot;至少5个字&quot;}) @MaxLength(12,{message:&quot;至多12个字&quot;}) loginId:string loginPwd:string age:number gender:'male'|'female'}const post = new RegUser()// post.loginId = &quot;asfsd&quot;validate(post).then(err =&gt; { console.log(err); }) class-transformer作用：将平面对象转换为类应用：假设一个应用场景，有一个用户数组，每个元素都是一个用户对象123456789101112131415161718[{ &quot;id&quot;: 1, &quot;firstName&quot;: &quot;Johny&quot;, &quot;lastName&quot;: &quot;Cage&quot;, &quot;age&quot;: 27},{ &quot;id&quot;: 2, &quot;firstName&quot;: &quot;Ismoil&quot;, &quot;lastName&quot;: &quot;Somoni&quot;, &quot;age&quot;: 50},{ &quot;id&quot;: 3, &quot;firstName&quot;: &quot;Luke&quot;, &quot;lastName&quot;: &quot;Dacascos&quot;, &quot;age&quot;: 12}] 现在有一个用户类1234567891011121314export class User { id: number; firstName: string; lastName: string; age: number; getName() { return this.firstName + &quot; &quot; + this.lastName; } isAdult() { return this.age &gt; 36 &amp;&amp; this.age &lt; 60; }} 当拿到用户数组的时候，就算类型约束成为User类，即使我们知道这里的每个元素的的确确都是用户类，但是ts不会把对象转换为类，所以不能访问类定义的方法，依旧只能访问自身的属性。此时使用class-transformer库里面的 plainToClass()方法可以把平面对象转换为class1234fetch(&quot;users.json&quot;).then((users: Object[]) =&gt; { const realUsers = plainToClass(User, users); // 现在realUsers数组里面的每个元素就都是User类了}); 类型演算typeof作用于类的时候，得到的是类的构造函数 keyof作用于类、接口、类型别名，可以获取这些类型的所有成员名组成的联合类型12345678interface User{ id:string pwd:string age:number}function printProp(obj:User,prop:keyof User){ console.log(obj[prop]);} in 通常和 keyof联用，限制索引器的取值范围，类型演算 1234567891011121314151617181920212223242526272829303132333435363738394041interface User{ id:string pwd:string age:number createDate:Date}type Userstring= {//将user的成员类型都转换成string [prop in keyof User]:string}//下面三个在lib有定义，可以直接作为泛型类型使用//将user的成员都设置为可选type Partial&lt;T&gt; = { [P in keyof T]?: T[P];};//只读type Readonly&lt;T&gt; = { readonly [P in keyof T]: T[P];};//非空type Required&lt;T&gt; = { [P in keyof T]-?: T[P];};//剔除T中能赋值给U的类型type Exclude&lt;T, U&gt; = T extends U ? never : T;//只保留T中能复制给U的类型type Extract&lt;T, U&gt; = T extends U ? T : never;NonNullable&lt;T&gt; 去掉null和undefined类型ReturnType&lt;T&gt; 得到函数返回值的类型 传入的T是函数的类型，不是函数，可以用typeofInstanceType&lt;T&gt; 得到构造函数的实例类型","link":"/2019/07/19/ts%E4%B8%89%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"title":"ts再体验——class类","text":"学习ts的class。 抽象成员应用场景：父类中，知道有些成员必须要存在，但是不知道具体的值是什么，在成员前面加abstract强约束在子类中一定要实现这个成员 注意事项： 必须在抽象类中，抽象成员，不管是方法还是属性，在子类中一定要继承 模板模式有些方法，所有子类实现的流程是完全一致的，只是某个步骤不一样，可以将这个方法提取到父类，在父类中完成整个流程的实现，对于实现不一致的方法，再将其做成抽象方法123456789101112131415161718192021222324252627282930313233343536373839404142class Chess { constructor() { this.x = 0; this.y = 0; } move(targetX, targetY) { console.log('相同的规则1'); console.log('相同的规则2'); if (this.rule) { return true; } return false; }}class Horse extends Chess { constructor() { super(...arguments); this.name = '马'; } rule() { throw new Error(&quot;马怎么走&quot;); }}class Pao extends Chess { rule() { throw new Error(&quot;跑怎么走&quot;); } constructor() { super(); this.name = '炮'; }}class Soldier extends Chess { rule() { throw new Error(&quot;兵怎么走&quot;); } get name() { return '兵'; }} 单例模式某些类的对象，在系统中最多只能有一个，为了避免开发者造成随意创建多个类的对象的错误，可以用单例模式强约束123456789101112131415161718192021class Board { constructor() { this.width = 500; this.height = 700; } init() { console.log('初始化'); } static createBoard() { if (this._board) { return this._board; } this._board = new Board(); return this._board; }}const b = Board.createBoard();const b2 = Board.createBoard();console.log(b === b2); //结果是true 类型保护函数通过这种函数会触发类型保护，该函数返回boolean123456789101112131415161718class Animal { //动物具有的共同属性}const animals = ['dog','cat','lion']; //一堆动物function hasFireShow(ani) { if (ani.singleFire &amp;&amp; ani.doubleFire) { return true; } return false;}animals.forEach(a =&gt; { if (hasFireShow(a)) { a.singleFire(); a.doubleFire(); }}); 索引器（成员表达式）注意： 索引器要写在所有成员之前 默认情况下，不会对索引器做严格的类型检查 打开配置”noImplicitAny”:true,//开启对隐式any的类型检查，但是这不仅仅影响索引器，很多地方都会增强类型检查 作用： 在严格的类型检查下，可以实现给类动态地增加成员 可以实现动态操作类成员 12345678class User{ [prop:string]:any constructor(public name :string,public age:number){} sayHello(){}}const u = new User('aa',22)u['6'] = 'sdf'u[5] = 'sdf' 在js中，所有的成员名本质上都是字符串，如果使用number作为成员名，会自动转换为字符串在ts中，如果某个类使用了两种类型的索引器，要求两种索引器的值必须是一样1234class myArray{ [prop:number]:string [prop:string]:string} this指向在ts中，允许在书写函数时，手动声明该函数中this的指向。将this作为函数第一个参数，该参数只用于约束this，并不是真正的参数，不会出现在编译结果中 12345678class User { constructor(public name:string , public age:number){} sayHello(this:User){ console.log(this,this.name,this.age); }} this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象 这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象","link":"/2019/07/10/ts%E5%86%8D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94class%E7%B1%BB/"},{"title":"ts初体验——类型系统","text":"学习ts的类型系统。 默认情况下，做出以下假设 假设当前的执行环境是dom 如果代码中没有使用模块化语句（import、export），便认为该代码是全局执行 编译的目标代码是ES3 两种方式更改以上假设 使用tsc命令的时候，加上选项参数 使用ts配置文件，更改编译选项（使用配置文件后，用tsc命令不用跟文件名tsconfig的生成命令是tsc –init 用到的辅助工具包 @types/node 官方的类型库，补充类型定义，相同的还有@types/jquery等 ts-node 编译时运行，不用生成js文件就可以运行 nodemon 选项参数 -e 只对什么后缀的文件监听 利用这些辅助工具可以在package.json中自定义命令1234&quot;scripts&quot;: { &quot;dev&quot;: &quot;nodemon --watch src -e ts --exec ts-node src/index.ts&quot;, &quot;build&quot;: &quot;rd /s /q dist &amp; tsc&quot; }, 其他类型 联合类型:多种类型选择一个，类型保护：对某个变量类型判断之后，在判断语句块中可以确定类型，typeof可以触发类型保护 void 用于约束函数返回值，表示没有返回 never 用户约束函数返回值，表示函数不能结束，一般是用于抛出异常或者无限循环 字面量类型：限定只能赋值为什么123456789字面量应用场景举例let gender : &quot;男&quot;|&quot;女&quot;let arr:[] arr变量只能赋值为空数组let user ={ name:string; age:number;} 元组 一个固定长度的数组，数组中每一项的类型确定(明确数组的长度和每一个元素)1let tuarr :[string , number] any 可以绕过类型检查，可以赋值任意类型 函数的相关约束函数重载：在函数实现之前，对函数调用的多种情况声明 可选参数：可以在某些参数名后加上问号，表示该参数可以不用传递,可选参数只能在参数的末尾，可以使用多个？ 默认参数值：在函数形参直接赋值，如下面例子的c初始化为012345function sum(a:number,b:number,c:number = 0) { }sum(3,4)sum(3,4,5) 枚举类型首先，为什么要用枚举A:字面量类型可以实现一些枚举也能做到的效果，但是会出现大量的重复代码，而类型别名虽然又可以解决代码重复的问题，但是如果要修改某个值，可能会出现大量的改动,并且字面量类型不会进入编译结果，而枚举类型会进入编译结果 先举个栗子吧12345678910111213141516//字符串枚举enum Gender{ male:'男', //要修改的话是修改后面的真值，使用枚举类型是使用前面的字段名 female:'女'}//数字枚举enum Permission{ Read = 1, Write =2 , Create =4 , Delete = 8}let gender :Gender = Gender.male 枚举的一些注意事项 枚举的值只能是字符串或者数字 枚举会出现在编译结果中，表现为对象 数字枚举的值会自增，如果数字枚举第一个没有赋值，那就从0开始，如果第一个赋值了，后面的就算没有赋值也会自增 被数字枚举约束的变量可以直接赋值为数字，但是最好不要 两种(数字，字符串)枚举的编译结果js差别挺大123456789101112131415enum Level { Level1 =1, Level2, Level3}这是数字枚举的编译结果，可以看出是把键值对方向又赋值了一遍var Level;(function (Level) { Level[Level[&quot;Level1&quot;] = 1] = &quot;Level1&quot;; Level[Level[&quot;Level2&quot;] = 2] = &quot;Level2&quot;; Level[Level[&quot;Level3&quot;] = 3] = &quot;Level3&quot;;})(Level || (Level = {}));因此在用Object.values遍历的时候会发现有6个结果 一个枚举中不要同时出现既有字符串字段又有数字字段 尽量使用字段名，而不是真值 模块化模块化标准如果设置是ES6：和正常写没有区别模块化标准是commonjs，导出变成exports的属性，默认导出变成exports.default 12345对于引入fs这种模块，使用module.exports导出的1、 import * as fs from &quot;fs&quot;;2、 import {readFileSync} from &quot;fs&quot;;3、 &quot;esModuleInterop&quot;: true, //启动es模块化交互非es模块导出 如果一定要用commonjs，写法则有点像是commonjs和es6的混合导出 export = {xxx}导入 import xxx = require(‘xxx’) 有关模块解析得另开一篇章节了 接口interface可以通过接口之间的继承实现多种接口的组合 使用类型别名可以实现类似的组合效果，通过&amp;，又叫交叉类型 接口与类型别名异同 子接口不能覆盖父接口的成员 交叉类型会把相同成员的类型进行交叉 出现既是string又是number的类型 都不出现在编译结果 123456789101112接口约束对象，interface User { name :string age:number say:()=&gt;void或者是 say():void}接口约束函数interface condition { (m:number):boolean} 1234交叉类型实现interface C extends A,Btype C = { T3:boolean} &amp; A &amp; B readonly关键字12345678type User = { readonly id :string name:string age :number readonly arr : readonly string[]}前面的readonly表示数组不能被重新赋值，但是可以push等，后面的readonly是修饰类型，不可push，pop等const arr: ReadonlyArray&lt;number&gt; = [1, 23, 4, 5]; class类类型的初始化检查启动严格检查 &quot;strictPropertyInitialization&quot;: true 初始化可以在三个位置进行，构造函数里或者属性位置或者构造函数参数属性可以设置 可选？，只读readonly12345678910111213class User{ readonly id:number //只读 name:string age : number gender: 'man'|'female' = 'man' pid ?:string //可选 constructor(name:string,age:number){ this.id = Math.random(); this.name = name; this.age = age; }} 修饰符public\\private\\protect当某个属性通过构造函数传参，没有经过改变就直接赋值给属性的时候，利用修饰符可以属性简写 123456789class User{ readonly id:number gender: 'man'|'female' = 'man' pid ?:string constructor(public name:string,public age:number){ this.id = Math.random(); }} 访问器用来控制属性的赋值和读取 123456789101112将上面构造函数中的 public age:number 改成private _age:numberset age(value :number){ if(value &lt; 0){ this._age = 0 }else{ this._age = value; } } get age(){ return Math.floor(this._age) } 泛型是指附属于函数、类、接口、类型别名之上的类型，相当于是一个类型变量，在定义时无法预先知道具体的类型，可以用泛型代替，只有调用的时候才能确定类型多数情况下，可以通过类型推导根据传递的参数得出泛型的类型如果无法推导，又没有写具体的泛型类型，默认为空对象 泛型约束 123456789101112131415161718192021222324import { log } from &quot;util&quot;;interface hasNamePropety { name: string}function nameToUpper&lt;T extends hasNamePropety&gt;(obj: T): T { obj.name = obj.name .split(' ') .map(s =&gt; s[0].toUpperCase() + s.substr(1)) .join(' '); return obj;}let o = { name: 'zheng qingyi', age: 18,}const newo = nameToUpper(o)console.log(newo); 多泛型使用123function mixinArray&lt;T,K&gt;(arr1:T[],arr2:K[]) : (T|K)[] { }","link":"/2019/07/10/ts%E5%88%9D%E4%BD%93%E9%AA%8C%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"},{"title":"Webpack拆包","text":"webpack打包文件vendor体积大怎么解决一直以来都是前端优化的一个关注问题，今天翻资料的时候发现webpack有一个拆包的功能也可以解决这个问题。 一、打包文件越来越大导致的问题 首屏加载变慢。前端框架的使用导致js文件加载完成之前只能显示空白或者少量内容。SSR服务端渲染可以改善这个现象，但是代价挺大的。 页面迭代导致浏览器缓存不可用。 公用库和框架无法跨页面共享。并非所有都是单页面应用，多页面应用的页面之间经常会有公用库和框架，但是对于这些，每个页面都会重复打包。 虽然引用的UI库例如Element—UI或者Antd都有提供按需加载的功能，可以有效减少打包文件体积，但是如果项目本身庞大需求组件多，还是会很大的。 二、用CDN外链引入 放到cdn上，在index.html外链引入 1&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.5/lodash.min.js&quot; /&gt; app.js文件import的还是要的，不然怎么注入全局 修改webpack的externals 123456externals: { lodash: '_', highcharts: 'Highcharts'}//key是文件名，就是install那个，value是这个模块抛出的变量 三、使用CommonsChunkPlugin拆包每使用一次该插件，会生成一个单独的文件(chunk，译作切片），这个文件中包含了多个入口chunk中的公共模块 配置项name：新的切片的名称，字符串或者字符串数组，可以是已经存在的chunk的名字 chunks。需要检查、提取公用模块的chunk。 minChunks。接受一个大于等于2的数组，表示的是至少有n个chunk中公用了这个模块，才会提取出来单独打包，也可以接受一个函数，函数接受两个参数，module和count，返回值为true的模块会被提取出来 fileName。文件命名模板，可以使用[name]、[hash]、[id]之类的变量占位符。 123456789101112new webpack.optimize.CommonsChunkPlugin({ name: 'charts', chunks: ['vendor'], minChunks: module =&gt; module.resource.indexOf('highcharts') &gt; -1}), new webpack.optimize.CommonsChunkPlugin({ name: 'ui', chunks: ['vendor'], minChunks: module =&gt; module.resource.indexOf('element-ui') &gt; -1})复制代码 优点将公用的模块提取出来单独打包 不会影响正常加载 有效利用浏览器缓存 可以跨页面公用","link":"/2020/03/15/webpack%E6%8B%86%E5%8C%85/"},{"title":"z-index引发的思考","text":"故事的是从一个小小的z-index开始的。今天突然看到一个问题。z-index 默认值是啥？以前的确没关注过这个，默认值难道不是auto，既然这么问那肯定有鬼了，盲猜又是IE的锅。 搜了一下得到答案：IE默认值是0，而FF是auto。那么这个问题算是答完了，但是隐藏在背后的知识点真的只有这些吗？于是乎引出了下面的名词 一个小例子1234567&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;inline-block&quot;&gt;#divA display:inline-block&lt;/div&gt; &lt;div class=&quot;float&quot;&gt; #divB float:left&lt;/div&gt;&lt;/div&gt; CSS就不写了，看class名字表达意思。注意在这里是inline-block的div先写在写float的div。最后结论是，不管这两个div顺序怎样，永远是inline-block的盒子在上(用背景色区分下就能看到了)。根究原因的话就引出了本文主角之一的层叠等级 层叠等级(stacking level) 所以display：inline-block会一直在float的上面。但是如果两个div都加一个opacity：0.9，那么结果变成，后面的div永远在前面的div上面 层叠上下文(stacking context)层叠上下文的元素层叠顺序是看z-index。但是这个z-index只在父级层叠上下文有意义。如果父级的z-index小于一个同级的，那么这个父级的子元素z-index设置再大也没用。 触发层叠上下文的常用的方式有 根元素 (HTML), 绝对相对固定定位 flex的item opacity transform filter will-change mix-blend-mode isolation 值得一提的是，上面这些不取默认值的才算 值得二提的是，4-7正好是触发硬件加速的四种css 值得三提的是，8-9正好的触发混合模式的三种方式之二？这么巧有故事吧 混合模式顺便谈下混合模式，毕竟这和z-index有关系。 z-index解决的是层叠(元素覆盖)问题，而CSS混合模式解决的是元素覆盖部分如何混合(如何表现)的问题 常用的三种css属性 mix-blend-mode元素内容和元素背景的混合体验效果戳这里 background-blend-mode背景和背景的混合体验效果戳这里 isolation希望混合模式只影响某一个或一些指定的元素用isolation: isolate。默认值是auto 其实只要可以创建层叠上下文的都可以起到阻断混合模式mix-blend-mode的效果，怎么创建层叠上下文看上面。特殊的是，background-blend-mode不会受影响，本来就不会影响其他元素","link":"/2020/02/27/z-index%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"},{"title":"事件循环机制和几种数组方法","text":"Everything runs in parallel except your code! 初次了解js的事件循环机制 事件循环（以及异步，回调）js 事件轮询机制 在js中同步和异步的任务会分别进入不同的执行场所，同步任务进入主线程异步的进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的Event Loop(事件循环)。 但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。 菠萝说的宏任务一般有：script，setTimeout，setInterval。 微任务：Promise，process.nextTick。 数组操作几种方法(codewar) 今天做的这道题让我回忆，以及get到了一些或旧或新的方法，这些方法都是挺有用的 filter()过滤filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。 例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：12345var arr = [1, 2, 4, 5, 6, 9, 10, 15];2 var r = arr.filter(function (x) {3 return x % 2 !== 0;4 });5 r; // [1, 5, 9, 15] split()分隔 分割字符串的方法注意这两个split(“”) 每个元素分隔split(“ “)以空格为分隔符分隔 几种遍历方法 回顾了一下js数组遍历的几种方法1、 普通for循环,最简单的一种，也是使用频率最高的一种，瀚程如是说，的确是最熟悉性能也是挺高 12for(j = 0; j &lt; arr.length; j++) { } 2、 12arr.forEach(function(e){ }); 3、 12Array.prototype.forEach.call(arr,function(el){ }); 4、 for(i in或者of arr){ } 5、 map遍历 arr.map(funtion(n){ }) DNS解析记录类型A 表明主机记录指向唯一的IP记录类型CNAME 一个域名指向另一个域名 买了一个新的域名尝试了将其指向原有的博客域名，一顿操作终于好了缓存真是个奇怪的东西，明明就是ping一样的地址，上一刻和下一刻效果不一样 添加虚拟主机的常用命令lnmp vhost addlnmp vhost listcd /home wwwroot/lnmp listcd 进去 找到index.html，vim模式编辑 express Post请求体 常用媒体类型是application/x-www-form-urlencoded 如果需要上传文件 multipart/form-data 如果是AJAX请求 application/json 最后附上一道题，有关异步的1234567891011setTimeout(function(){ console.log('1') }); new Promise(function(resolve){ console.log('2'); }).then(function(){ console.log('3') }); console.log('4'); 这段代码的运行顺序 2，4，3，1原因就是 然后回到开头的代码。因为settimeout是宏任务，虽然先执行的他，但是他被放到了宏任务的eventqueue里面，然后代码继续往下检查看有没有微任务，检测到Promise的then函数把他放入了微任务序列。等到主线进程的所有代码执行结束后。先从微任务queue里拿回掉函数，然后微任务queue空了后再从宏任务的queue拿函数。","link":"/2018/07/16/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E5%87%A0%E7%A7%8D%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"title":"浏览器页面缩放原理引发的思考","text":"浏览器按住ctrl和鼠标滚轮缩放原理。 搜一搜万能的互联网怎么说的第一种说法(改变html宽高) 在没有确定html的width和height为px情况下，是通过缩放html标签的高度和宽度来实现的。道理不难理解，html作为参照物，当你想放大的时候，其实浏览器执行的是缩小html的宽和高。为html设定一个所谓的绝对宽度和高，即px为单位（虽然这个也并非绝对单位），可以清晰的看到html画布的放大和缩小。但是在设置了HTML的w和h后，其缩放机理还没有摸透，猜测可能是改变了document的宽和高。 12345678910111213//通过一个媒体查询例子看看@media screen and (max-width: 1000px){ body{ background-color: red; } } @media screen and (min-width: 1001px) and (max-width: 2000px){ body{ background-color: blue; } } 结果发现ctrl滚轮放大 以及 改变整个浏览器窗口使其缩小的时候，都会变成红色，通过开发者工具的审查元素也能发现html的width的确变小了 第二种说法(改变逻辑尺寸)假定浏览器初始值是100px，我们在屏幕上看到的是10cm，那么它就是将10cm的物理长度划分成了100份，每一份是1px。 当进行了网页放大，比如视觉上放大了一倍，那么原来代表1px的物理长度区域，只能代表0.5px，也就是说现在10cm的长度，只能表示50px。也就是说，物理上没有变化，但是逻辑上，尺寸缩小了一倍。 比如你屏幕分辨率本来是1000px，网页放大一倍以后，逻辑尺寸就变成了500px。 第三种说法(改变zoom值) CSS 有 zoom 属性，可以控制内容的缩放。浏览器的缩放大概实现方式类似吧。至于错位问题，大部分浏览器对字体都有默认的最小值，当小于最小值后，文字并不会被缩放，导致了内容的折行，从而把布局撑开。 这个说法虽然没有和我一开始的想法分辨率挂钩，但是zoom这个属性我也去试了一下 随便挑了一个页面调整页面内容100%，然后滚动放大到125%的时候，做了一个视窗截图。和我在100%的情况下对使用zoom:125%，在一些网站上是一模一样的，在一些网站上会出现错位问题，稍微错位了一点，整体效果接近，这跟原文的说法一致。但是这并不能说明浏览器的ctrl+滚了的原理是这个，只能说可以这么达到实现的效果吧。 推荐好文以及详细解读浏览器缩放原理英文原文 中文翻译 顺便谈下zoom这个属性原本是IE专属的，用来清除浮动、清除margin重叠等。如今除了FF不支持，-webkit内核的浏览器例如Chrome和移动端浏览器是支持的，但是用法不一样 在非IE下的作用是放大两倍，zoom:1|2除了宽高边距也包括字体，但是这个属性是一个不标准的css属性，因此一般不用zoom来实现缩放效果，现在要放大或者缩小直接用css3的transform属性，transform才是正统标准，当然IE678依然不支持，这点就可以用zoom弥补了，刚好zoom可以支持IE678 在IE下的作用除了缩放，更多的是利用他可以触发ie的hasLayout，用于清除浮动、清除margin的重叠 清除浮动常用 overflow:hidden; zoom:1; 解决子元素浮动时候父元素不随着自动扩大的问题（margin重叠也是），一般要在浮动元素的父元素加上overflow:auto； zoom:1; 和transform:scale的差异 zoom的缩放是相对于左上角的；而scale默认是居中缩放； zoom的缩放改变了元素占据的空间大小，引起重绘回流；而scale的缩放占据的原始尺寸不变，布局不变，只会重绘不会回流 zoom和scale对元素的渲染计算方法可能有差异，效果上看zoom缩放的图片会更加清晰，scale比较模糊 对文字的缩放规则不一致。zoom缩放依然受限于最小12像素中文大小限制；而scale就是纯粹的对图形进行比例控制，文字50%原来尺寸。 缩放在不同浏览器下获取屏幕分辨率情况差异ctrl+-进行缩放的时候的时候，不同浏览器获取的屏幕分辨率情况不一样。 1234567891011//物理分辨率，即显示器的当前分辨率：window.screen.widthChrome下，缩放不影响： window.screen.availWidth == window.screen.width == 显示器宽度火狐: 缩放是影响其值的： window.screen.availWidth == window.screen.width == (显示器宽度 / 缩放比例) IE: 缩放是影响其值的： window.screen.availWidth == window.screen.width == (显示器主显示器宽度 / 缩放比例) PS: 主显示器是指，当前电脑连接多个显示器，任务栏所在的显示器为主显示器。 12//浏览器可见区域(视窗)分辨率：document.body.clientWidthChrome, FF, IE: document.body.clientWidth == (浏览器可视区域宽度 / 缩放比例) 如何检查浏览器的缩放状态(兼容各种浏览器)PS:这里缩放不是指浏览器大小的缩放，而是指浏览器网页内容的百分比缩放 不管IE6，因为 IE6 只能对文本进行缩放。 window.devicePixelRatio 目前Firefox、chrome等都得到了很好的支持。 IE 的处理方法了，IE 提供了 window.screen.deviceXDPI 和 window.screen.logicalXDPI 两个属性， 对于以上两种都不支持的浏览器，还可以利用window.outerWidth 和 window.innerWidth 这两个属性。 1234567891011121314151617181920212223function detectZoom (){ var ratio = 0, screen = window.screen, ua = navigator.userAgent.toLowerCase(); if (window.devicePixelRatio !== undefined) { ratio = window.devicePixelRatio; } else if (~ua.indexOf('msie')) { if (screen.deviceXDPI &amp;&amp; screen.logicalXDPI) { ratio = screen.deviceXDPI / screen.logicalXDPI; } } else if (window.outerWidth !== undefined &amp;&amp; window.innerWidth !== undefined) { ratio = window.outerWidth / window.innerWidth; } if (ratio){ ratio = Math.round(ratio * 100); } return ratio;}; 如何禁用浏览器的缩放12345678910111213141516&lt;script language=&quot;javascript&quot;&gt; var scrollFunc = function (e) { e = e || window.event; if (e.wheelDelta &amp;&amp; event.ctrlKey) { //IE/Opera/Chrome event.returnValue = false; } else if (e.detail) { //Firefox event.returnValue = false; } } /*注册事件*/ if (document.addEventListener) { document.addEventListener('DOMMouseScroll', scrollFunc, false); } //W3C window.onmousewheel = document.onmousewheel = scrollFunc; //IE/Opera/Chrome/Safari &lt;/script&gt; window.outerWidth获取浏览器窗口外部的宽度。 它表示整个浏览器窗口的宽度，包括边栏window.innerWidth获取浏览器可视区域的宽度，也就是页面的宽度","link":"/2020/04/04/%E4%BB%8Ectrl%E6%BB%9A%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"},{"title":"关于vue里面scoped","text":"前期概要：在开发这个B2B的时候，在引用其中一位开发者写的组件时，出现了样式上的崩坏，结合之前翻阅文档得出是scoped的问题 scoped作用在vue组件中，在style标签上添加scoped属性，vue通过在DOM结构以及css样式上加唯一不重复的标记，以保证唯一，达到样式私有化模块化的目的，很好的实现了样式私有化的目的。但是之后如果对公共组件样式做调整，如果添加了scoped属性，那么样式将会变得不易修改。本次就出现了这样的问题，因为父子组件中用到了同样的类名 例子123456789101112131415161718192021222324252627282930313233//button.vue&lt;template&gt; &lt;div class=&quot;button-warp&quot;&gt; &lt;button class=&quot;button&quot;&gt;text&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt; .button-warp{ display:inline-block; } .button{ padding: 5px 10px; font-size: 12px; border-radus: 2px; }&lt;/style&gt;// 渲染之后html &lt;div data-v-2311c06a class=&quot;button-warp&quot;&gt; &lt;button data-v-2311c06a class=&quot;button&quot;&gt;text&lt;/button&gt;&lt;/div&gt;// 渲染之后css.button-warp[data-v-2311c06a]{ display:inline-block;}.button[data-v-2311c06a]{ padding: 5px 10px; font-size: 12px; border-radus: 2px;} 此时用一个组件引用123456789101112131415161718192021222324252627282930313233343536//content.vue文件里面模板&lt;div class=&quot;content&quot;&gt; &lt;p class=&quot;title&quot;&gt;&lt;/p&gt; &lt;!-- v-button假设是上面定义的组件 --&gt; &lt;div data-v-2311c06a class=&quot;button-warp&quot;&gt; &lt;button data-v-2311c06a class=&quot;button&quot;&gt;text&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;//渲染出来的html&lt;div data-v-57bc25a0 class=&quot;content&quot;&gt; &lt;p data-v-57bc25a0 class=&quot;title&quot;&gt;&lt;/p&gt; &lt;!-- v-button假设是上面定义的组件 --&gt; &lt;div data-v-57bc25a0 data-v-2311c06a class=&quot;button-warp&quot;&gt; &lt;button data-v-2311c06a class=&quot;button&quot;&gt;text&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;//渲染出来的css.button-warp[data-v-2311c06a]{ display:inline-block;}.button[data-v-2311c06a]{ padding: 5px 10px; font-size: 12px; border-radus: 2px;}/*content.vue渲染出来的css*/.content[data-v-57bc25a0]{ width: 1200px; margin: 0 auto;}.content .button[data-v-57bc25a0]{ border-raduis: 5px;}虽然我们在content添加了想要修改button组件的样式的代码，但是由于.content .button这句在末尾加的是content组件的scoped标记，最后这句其实根本作用不到我们想要的DOM节点上，所以这种情况我们在content内部写的任何样式都不会影响到button.vue组件， 总结scoped原理1、给HTML的DOM节点加一个不重复data属性(形如：data-v-2311c06a)来表示他的唯一性 2、在每句css选择器的末尾（编译后的生成的css语句）加一个当前组件的data属性选择器（如[data-v-2311c06a]）来私有化样式 3、如果组件内部包含有其他组件，只会给其他组件 的最外层标签加上当前组件的data属性","link":"/2018/11/21/%E5%85%B3%E4%BA%8Evue%E9%87%8C%E9%9D%A2scoped/"},{"title":"几种模块化规范比较","text":"Commonjs,AMD，CMD，ESModule 4中模块化规范比较 commonjscommonjs是node应用的模块规范，每个文件都是一个模块 每个模块内部，module代表当前模块，也就是文件本身 module.exports属性是对外的接口，加载一个模块其实就是加载module.exports 每个模块都有一个exports变量，指向module.exports。相当于var exports = module.exports，但是要用直接用exports的话，只能在成员上添加，例如exports.add = function(){}，不能直接赋值，会切断和module.exports的连接，所以尽量不要直接用exports require加载模块，返回的是引入模块的exports对象 模块加载规则根据require字符串参数的不同 /开头，绝对路径 ./ 相对路径 一个模块的名字，加载的是核心模块，位于各级目录下的node_modules，寻找的路径是从同级目录下开始往上找 如果是路径，例如require('aaa/bbb/ccc')先找aaa位置，再找后面的 如果都没有找到，node会给文件名添加.js,.json,.node后缀，再去搜索，分别以js脚本解析，json文本解析，二进制文件解析 第一次加载该模块，node会缓存该模块。再次加载，直接从缓存中取出该模块的module.exports属性。缓存是保存在require.cache删除缓存是用delete require.cache[moduleName];基本不会用到这个的 模块输出的变量就跟原模块没有关系了，原来的模块变化，不会影响到输出的变量 AMD与commonjs的区别AMD规范则异步加载模块，允许指定回调函数 CommonJS规范加载模块是同步的，只有加载完成，才能执行后面的操作。 123456789//commonjs写法var clock = require('clock');clock.start();//AMD写法require(['clock'],function(clock){ clock.start();}); AMD和CMD的区别12345//CMD的写法define(function(require, exports, module) { var clock = require('clock'); clock.start();}); AMD和CMD最大的区别是依赖模块的执行时机不同，而不是加载时机或者加载方式不同，其实二者皆为异步加载模块 AMD依赖前置，js可以方便知道依赖模块是什么，立即加载；而CMD就近依赖，需要把模块变为字符串解析一遍才知道依赖了那些模块，但是解析模块用的时间短到可以忽略 ES6的模块化export后面跟要暴露的对象，export default是缺省，一个模块只能有一个default12345import * as name from &quot;xxx&quot; //通配符引入所有export的变量， as作用是重命名import {a,b,c} from &quot;xxx&quot; //引入指定的变量import x from &quot;&quot;//没有使用{}的，这样写会引入export defaultimport &quot;./1.jpg&quot;//模块也可以是图片，js文件，这样直接引入模块的代码，不引入内部成员let promise = import(&quot;xxx&quot;) //也支持异步引入，一定要绝对路径，在编译的时候会生成异步的模块，前面带有数字那些文件就是","link":"/2019/07/19/%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83%E6%AF%94%E8%BE%83/"},{"title":"2018&#x2F;07&#x2F;19","text":"网络层相关网关实质上是一个网络通向其他网络的IP地址主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机（如附图所示）。网络A向网络B转发数据包的过程 继续学习CSS看了瀚程给大爷的新时代修BUG获益匪浅","link":"/2018/07/19/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E7%AC%AC%E4%B8%83%E5%A4%A9/"},{"title":"2018&#x2F;07&#x2F;18","text":"Express初学 express express xx生成一个express文件，进入bin，npm start 等同于node ./bin/www 运行node服务 package.json下列出的模块表明是运行所需要的，npm install 会自行安装。便于客户端执行服务。 jade模板引擎，在express开发中有粗略看过，当初还没学前端htmlcss基本懵逼，现在看好多了。模板引擎是用来简化html代码的，准备晚点再看看。 路由通配符 1234router.post('*',function(req,res,next){ xxxxxx; next()；}) 路径如果设定是*，表明所有的请求都要经过这个路由，再执行next方法，比如用来检测用户在一个页面停留的时间是否过长，从而判断登录状态。 继续学css","link":"/2018/07/18/%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%8C%96%E5%8F%B2%E4%B9%8B%E7%AC%AC%E5%85%AD%E5%A4%A9/"},{"title":"多角度看待HTTPS","text":"本文从HTTPS的作用、缺点、与HTTP的区别、加密算法、数字证书、SSL/TLS等角度介绍HTTPS的知识点 一、HTTPS介绍1.作用 内容加密 保证数据传输的安全； 身份验证 确认网站的真实性； 数据完整性 防止内容被第三方冒充或者篡改2.缺点 需要进行非对称的加解密，且需要三次握手。首次连接比较慢 出于安全考虑，浏览器默认不会在本地对HTTPS缓存。Firefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。IE只要http头允许就可以缓存https内容 3.和HTTP的区别 HTTP明文传输，而后者ssl加密，密文传输 端口不一样，80and443 http的连接是无状态的(不验证通信双方)，Https可进行身份认证 https要到CA申请证书 4.HTTP无状态无连接 无状态的意思是，协议没有记忆能力，对同一个url的请求没有上下文关系，每个请求都是独立的。后来出现了cookie 无连接的含义是限制每次建立连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可尽快释放资源。后来网页复杂了，嵌入图片什么的，每次访问都要建立tcp连接太低效，就出现了keep-alive 二、相关技术1. 对称加密常见的有DES、AES、RC4 2. 非对称加密 需要公钥私钥。常见算法有RSA。加密内容的长度有限制，不能超过公钥长度。 3. 摘要算法 单向散列(hash)算法，常见MD5 4. 数字签名非对称加密和数字摘要的结合应用。明文 ——&gt; hash算法 ——&gt; 摘要 ——&gt; 私钥加密 ——&gt; 数字签名 数字签名只能验证数据的完整性和身份验证，数据本身是否加密不属于数字签名的控制范围 5. 数字证书1） 数字证书的作用对请求方来说，要用公钥解密发送方发过来的证书里面的摘要，这个公钥怎么保证就是对方的呢？就要借助权威的值得信赖的第三方机构CA(证书颁发机构) 2） 颁发证书过程用户首先产生自己的密钥对，并将公钥及部分个人身份信息传送给认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后认证中心将发给用户一个数字证书。 3） 证书包含内容 证书颁发机构的名称 证书本身的数字签名 证书持有者公钥 证书签名用到的Hash算法4）怎么验证证书有效前提：浏览器默认都会内置CA根证书，根证书包含了CA的公钥 验证证书颁发的机构是否存在，浏览器不认识，直接认为是危险证书 存在的话根据CA名，找到对应内置的CA根证书。用证书里面的公钥，对摘要解密，不行表现危险证书 解密得到摘要A，然后再根据证书提供的的HASH算法计算出证书的摘要B，对比A与B，若相等则正常，否则就是被篡改过的。 证书可在其过期前被手动吊销，目前较新的浏览器如Chrome、Firefox、Opera和Internet Explorer都实现了在线证书状态协议（OCSP）以避免这种情况：浏览器将目标网站提供的证书的序列号通过OCSP发送给证书颁发机构，后者会告诉浏览器证书是否还是有效的。 三、SSL与TLSTLS建立在SSL 3.0协议规范之上，分为记录协议和握手协议 TLS比SSL优势 消息认证使用密钥散列法更安全：TLS使用“消息认证代码的密钥散列法”（HMAC），SSL3.0使用的是键控消息认证（MAC），HMAC比MAC功能更安全。 伪随机功能增强（PRF）：PRF生成密钥数据(那三个随机数)。在TLS中，PRF使用两种散列算法保证其安全性。 已完成消息验证改进。TLS将此已完成消息基于PRF和HMAC值之上， 一致证书处理。与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。 握手过程 恢复会话 session ID。每一次对话都有一个编号。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的“对话密钥”，而不必重新生成一把。 session ID是目前所有浏览器都支持的方法，缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发送到另一台服务器，就无法恢复对话。 session ticket。 上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，包含了对话密钥和加密方法。恢复会话的时候。当服务器收到session ticket以后，如果可以解密，就不必重新生成对话密钥了。 目前只有Firefox和Chrome浏览器支持。","link":"/2020/02/26/%E5%A4%9A%E8%A7%92%E5%BA%A6%E7%9C%8B%E5%BE%85HTTPS/"},{"title":"小程序初体验","text":"初学小程序相关知识 小程序版本分为预览版本 开发版本 体验版本 审核版本 线上版本 js在不同地方的构成浏览器是 ECMAScript NPM DOM BOMNodeJS中 ECMAScript NPM Native小程序中 ECMAScript 小程序框架 小程序API App构造器的参数1234567App({ onLaunch: function(options) {}, onShow: function(options) {}, onHide: function() {}, onError: function(msg) {}, globalData: 'I am global data'}) 场景值 场景 appId信息含义 1020 profile 页相关小程序列表 返回来源公众号 appId 1035 公众号自定义菜单 返回来源公众号appId 1036 App 分享消息卡片 返回来源应用appId 1037 小程序打开小程序 返回来源小程序 appId 1038 从另一个小程序返回 返回来源小程序 appId 1043 公众号模板消息 返回来源公众号 appId 全局数据1234567// app.jsApp({ globalData: 'I am global data' // 全局共享数据})// 其他页面脚本other.jsvar appInstance = getApp()console.log(appInstance.globalData) // 输出: I am global data 所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理。 生命周期 页面初次加载的时候，微信客户端就会给Page实例派发onLoad事件，Page构造器参数所定义的onLoad方法会被调用，onLoad在页面没被销毁之前只会触发1次，在onLoad的回调中，可以获取当前页面所调用的打开参数option，关于打开参数我们放在这一节的最后再展开阐述。页面显示之后，Page构造器参数所定义的onShow方法会被调用，一般从别的页面返回到当前页面时，当前页的onShow方法都会被调用。在页面初次渲染完成时，Page构造器参数所定义的onReady方法会被调用，onReady在页面没被销毁前只会触发1次，onReady触发时，表示页面已经准备妥当，在逻辑层就可以和视图层进行交互了。以上三个事件触发的时机是onLoad早于 onShow，onShow早于onReady页面不可见时，Page构造器参数所定义的onHide方法会被调用，这种情况会在使用wx.navigateTo切换到其他页面、底部tab切换时触发。当前页面使用wx.redirectTo或wx.navigateBack返回到其他页时，当前页面会被微信客户端销毁回收，此时Page构造器参数所定义的onUnload方法会被调用。 打开参数页面Page构造器里onLoad的option可以拿到当前页面的打开参数，其类型是一个Object，其键值对与页面URL上query键值对一一对应 常见的事件类型 类型 触发条件 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchcancel 手指触摸动作被打断，如来电提醒，弹窗 touchend 手指触摸动作结束 tap 手指触摸后马上离开 longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 longtap 手指触摸后，超过350ms再离开（推荐使用longpress事件代替） transitionend 会在 WXSS transition 或 wx.createAnimation 动画结束后触发 animationstart 会在一个 WXSS animation 动画开始时触发 animationiteration 会在一个 WXSS animation 一次迭代结束时触发 animationend 会在一个 WXSS animation 动画完成时触发","link":"/2019/03/29/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"小程序续篇","text":"接上一篇小程序初体验 有关样式1234567891011内联样式可以配合数据绑定&lt;view style=&quot;width:500rpx;height:30px;background-color:{{colorValue}};&quot;&gt;&lt;/view&gt;Page({ data:{ colorValue:'red' }})静态样式写入类class,动态样式写入style内联样式中选择器权重雷同，!important一般用在修改使用插件的样式 MINA框架 运行机制启动(热启动与冷启动)(小程序没有重启的概念)热启动：假如用户已经打开过某小程序，然后在一定时间内（五分钟）再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台 冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。那么什么情况下会销毁，主要是两种情况 小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁 当短时间内（5s）连续收到两次以上收到系统内存告警，会进行小程序的销毁 更新在冷启动的时候如果发现新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。 如果需要马上应用最新版本，可以使用 wx.getUpdateManager API 进行处理，这个API调用代码放在app.js的onLaunch。12345678910111213141516171819202122232425262728293031323334// 获取小程序更新机制兼容 if (wx.canIUse('getUpdateManager')) { const updateManager = wx.getUpdateManager() updateManager.onCheckForUpdate(function (res) { // 请求完新版本信息的回调 if (res.hasUpdate) { updateManager.onUpdateReady(function () { wx.showModal({ title: '更新提示', content: '新版本已经准备好，是否重启应用？', success: function (res) { if (res.confirm) { // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启 updateManager.applyUpdate() } } }) }) updateManager.onUpdateFailed(function () { // 新的版本下载失败 wx.showModal({ title: '已经有新版本了哟~', content: '新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~', }) }) } }) } else { // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示 wx.showModal({ title: '提示', content: '当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。' }) } 生命周期程序的生命周期onLaunch onShow onHide onError 页面的生命周期 onLoad 页面初次加载的时候调用，页面销毁前只调用一次 在回调中可以得到打开参数 onShow 页面显示后调用 从别的页面到这也会调用 onReady 初次渲染完成调用 在onShow之后调用 销毁前只有一次 onHide 打开新界面的时候，当前页面调用 onUnload 关闭界面的时候调用 路由 路由方式 触发时间 路由前页面调用啥 初始化 小程序打开的第一个界面 打开新界面 wx.navigateTo == onHide 重定向 wx.redirectTo == onUnload 返回 wx.navigateBack == onUnload Tab切换 wx.switchTab == 重启 wx.relaunch == onUnload 登录流程图 遇到的坑在用code换取到session_key和openid时，直接data.openid是拿不到的，经过检验类型，此时返回的是json字符串，需要自行JSON.parse() wx.getUserInfo 不能用了 需要用button打开类型设定为getUserInfo才能","link":"/2019/07/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%AD%E7%AF%87/"},{"title":"常见字符编码区别","text":"查阅并总结一些常见的字符编码类型，介绍其特点以及之间的区别。 字符编码的常用种类介绍 微信公众号回复、接收消息中中文乱码问题的分析及解决 1、ISO8859-1(读 Latin-1)最早的编码，单字节，字符范围0-255，应用在英文上，无法表示中文。 由于是单字节，和计算机最基础的表示单位(Byte字节)一致，所以很多时候，仍然使用ISO8859-1，其实很多协议也确实是默认使用该编码，尽管不能表示中文，但是可以在另一种编码的基础上做处理，例如虽然”中文”两个字不存在iso8859-1编码，以gb2312编码为例，应该是”d6d0 cec4”两个字符，使用iso8859-1编码的时候则将它拆开为4个字节来表示：”d6 d0 ce c4 2、ASCII如今最通用的单字节编码，主要应用在英语和其他西欧语言 3、GB2312前面两种编码都不支持中文，于是中国制定了GB2312编码，专门表示汉字，考虑到一个字节8位只能表示256个字符，因此该编码是双字节编码，英文字母的表示和ISO8859-1一致(也就是兼容了它)，但是只支持简体汉字。与之对应的就有BIG5，中华民国制定的繁体汉字编码规范 4、GBK(大字符集)GBK是GB2312基础上扩容并兼容的标准，也是双字节,包含所有亚洲文字，即简体中文、繁体中文、日语、韩语等，同时收录的汉字也比GB2312和BIG5都要多 5、Unicode如果每个国家、地区都用自己的一套编码规范，不可避免会有冲突，于是乎Unicode就成为了实现大一统的救世主，将所有的语言统一到一套编码里面，就不会有乱码问题了。 Unicode标准不断发展，目前最常用的还是2个字节表示一个字符，有些生僻字4个字节。现代OS和大多数编程语言都是直接支持Unicode的，而且完全兼容ASCII(就在一个字节的ASCII前面添上8个0嘛)，当然缺点就是，在存储英文字符的时候，浪费了一倍的空间 6、UTF-16UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。 7、UTF-8针对Unicode和UTF-16的浪费现象(有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，并且现在的网络带宽还非常有限，这样会增大网络传输的流量)需要把Unicode编码转为一种“可变长编码”的UTF-8。UTF-8在原来Unicode的基础上根据数字大小编码成1-6个字节，常用的英文就是1字节，汉字一般3字节，生僻字4-6字节。 同时由于英文是1个字节，所以ASCII码是可以当成其中的一部分的，这样的好处就是原来支持ASCII的旧软件可以再UTF-8下继续运行。 UTF-8 有以下编码规则： 如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。 如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。 如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节 计算机内存的编码转换在计算机内存中统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件","link":"/2020/10/26/%E5%B8%B8%E8%A7%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%8C%BA%E5%88%AB/"},{"title":"迟到的暑期培训总结","text":"早就应该写的了，拖着拖着就到现在了 日常 开张的前几天，做牛做马当木工，总算是把原本空荡荡的房间变得有模有样了 之后的前半段时间真的是被奥克斯的hot wind 逼疯了，在空调师傅的师傅拯救下终于感受到了什么是凉爽，虽然空调修好后一堆人感冒生病(AUX:这锅我背了) 期间大爷和holy经常拍大家伙的黑照，然后P表情包，中午大致三足鼎立 开黑打王者，肝痒痒鼠，睡觉；晚上吃完饭后也是王者，吃鸡，阴阳师，元气，看番看剧 经历了两碗的生日party，那晚的场面一度混乱，一切都是从大爷反手往我脸上一糊开始~~~ 培训时间进入尾期的时候，，看了几天的电影(无间道：这锅我背了)，不得不说无间道真的好看，还有傻嗨三宝看沙海，附上宝图一张 学习还是学会了挺多东西，虽然也有很多东西还没学进行一波非常简洁的概括，可能会漏掉一些(详情请见之前的博文) 知道git的多人合作流程 有了自己的云服务器 http和https的瓜葛 深入了解事件循环机制 js基础知识譬如继承、作用域、上下文 express的各种操作 HTML和CSS基础的学了，可以做出像新世界这种简单的界面了 做项目的时候经历了各种逻辑风暴和BUG袭击 Affair项目后台方面剩下一个消息界面的逻辑实在是搞不清，绕来绕去都是不妥的，其他的接口已经写好并测试完毕(有一些我是觉得逻辑上还能更清晰的，但是现在没有技术)，然而对接并没有完成 放假在家也是会继续学习的，学习使我快乐 从化之旅开门见山：这次从化别墅温泉之旅真的是非常非常嗨森✧｡٩(ˊᗜˋ)و✧*｡ 在华润万家大扫购并达成了1436会师，之后一起滴滴前往别墅 初入别墅，四层(还是五层？)的设计，温泉，烧烤摊，电影房，桌游房，麻将房，唱K区应有尽有 当天下午大一的唱K(前半场是浩立和大爷的主场，后半场是屹彬的主场)，大二的做饭，此处表扬居家好男人林荣耀，不仅代码敲得溜、天天跑业务、还能烧得一手好菜，可谓是出得厅堂入得厨房，品尝到了周老板做的超级美味的传说中的海底捞版本的面筋塞蛋和小恬恬香喷喷的炒饭 吃完饭轮到大一的负责准备晚上烧烤用的食材，大二的去休息唱K啦(小恬恬唱的贼好听)晚上，国家一级烧烤运动员jio大爷和周老板的烧烤摊开张，其他人则是在旁边打UNO嗷嗷待哺 人生第一次泡温泉，这个水温有毒，经久不衰盖如此乎，经过温泉水洗礼整个人都要升天了 半夜因为看不了电影，就一堆人挤在2张床上听所谓的恐怖故事，然而并没有发觉哪里恐怖，催眠了一个菠萝就有的。 之后除了麻将组决战到天光其他人差不多都是4点多回各自的房间训教了 第二天早上收拾东西走人，吃了一顿丰盛的早午餐就搭车翻来了 前进吧无需鲜衣怒马不用壮志豪言","link":"/2018/08/20/%E6%9A%91%E6%9C%9F%E6%80%BB%E7%BB%93%E6%8A%A5%E5%91%8A/"},{"title":"正则表达(后续再补充)","text":"正则表达相关。写法两种js 风格的是 let reg = new RegExp(‘\\d+’,’g’) perl 风格的是let reg = /\\d+/g; /正则表达式主体/修饰符(可选) 在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。其他方法test()返回boolean search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 修饰符 描述 i 大小写不敏感 g 全局匹配 m 多行匹配 y 全局匹配，但是在上一次匹配后紧跟着的下一个开始 u 正则表达式中有大于两个字节的情况加 最常用i,g es6中flags属性可以获得修饰符sticky属性可以判断是否使用y修饰，返回boolean 处理的正则表达式中有大于两个字节的，要加修饰符ues5中的 /^.$/ 可匹配任意字符，在es6中要加u才能识别超过两个字节的，但是换行回车行分隔段分隔这四个点(.)也不能匹配","link":"/2019/03/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE-%E5%90%8E%E7%BB%AD%E5%86%8D%E8%A1%A5%E5%85%85/"},{"title":"第一次周结（至5-28）","text":"javascript部分express部分git部分博客部分 javascript部分大致进度就是红宝书的前五章以及第六章中部了，差点小尾巴，以下是随手列一些1、&lt; script&gt;元素用于在html中插入js的代码，可以用src属性导入内部或外部的的js文件或者url。&lt; script&gt;的代码按照先后顺序解析，一般放在body的内容的后面，用defer async可以就可以实现延迟或异步解析脚本 2、在网页在开头写”use strict”进去严格模式3、文档模式分混杂和标准，经常见到这样子的html5标准模式 4一些基础概念在之前学习Node的时候了解过了，操作符，语句也跟C语言差不多我觉得 5、很多地方对象调用valueof的时候会自动地间接地调用toString(),所以我的理解是valueof返回的是最适合该对象类型的原始值 6、这个应该不怎么会用到，先记录下来吧infinity*0=NaN infinity/infinity=NaN被除数有限而除数无穷=被除数，被除数无穷 而除数有限=NaN 7、以前没见过with语句，对同一个对象多个操作的时候可以用with（）{}限制作用域 8、垃圾收集机制跟java的差不多，js最常用的垃圾收集方式还是标记清除 9、执行环境，就是作用域，每一门语言这个都是很重要的内容，js没有块级作用域,比如下面这个 if(true){ var color='blue';} alert(color); 在C或C++,JAVA中 color是局部变量，执行完if语句后就销毁了，但是在js中不会，该变量会自动添加到最近的执行环境，这里是全局 10、几大引用类型Object,Array,Date跟Java类似，学习基本包装类型的时候我竟然想到了java里的自动装箱？差不多吧我觉得；RegExp这个类型之前没接触过，跟正则表达式挂钩..我觉得需要先去学一下正则表达式的种种，做考核的时候有想着给登录注册那里加一个检测机制，判读用户的输入是否符合格式，在这里就用到了正则，当然那个时候个人是粗略看了一下而已 express部分其实一开始是先看着发在群里的那个《node与express开发》，看到handlebars前面那块就先打住了，因为在第四章的时候提到，要么跟随书本的实例手动，要么用官方的存储库，突然就想起git的各种命令。。所以在第六章结束后就去了网上找了资料补了下git和github的内容，还挺详细的。PS：认识一个新的东西QA，质量评价，竟然还有专门的QA职业，大千世界无奇不有 git部分万物起源于init初始化一个本地仓库先git add 再 git commit -m”说明文字”git status查看工作区状态，有什么改动，提交都可以看到，贼方便。git diff可以看到改动了啥git log查看提交历史git reflog查看命令历史，配套使用来确定版本号用来控制版本 参数 –pretty=oneline美观点，跟db的命令find().pretty()一个道理，毕竟丑是原罪git reset –hard xxxx(版本号或者HEAD^) 版本号可以不用打完整的，太长了 文件已修改，未add到暂存区:git checkout - - file可还原文件已修改，并add到暂存区未commit：三种方法，第一种好理解，其余的是从网上找来的另外的方法 关联github的操作git remote add origin git@github.com:git_username/repository_name.gitgit push origin master推送最新修改到github git clone git@github.com:xxxx 可以克隆别人的库，我在这周搭博客的时候，有试过切换主题，clone就发挥作用了git tag+标签名+版本号 作用就是给版本起个名v1.9v2.0 博客部分最常用的几个命令hexo g 生成静态文件hexo d deploy我的理解就是部署到githubhexo s 本地浏览 localhost:4000hexo n “文章名” 创建一个文档，然后就写写写（要用markdown语法，除了在马克飞象用的那些，应该还有更多可以让文章更漂亮的？） 要做出一个像模像样的博客还有好多东西要搞，慢慢来吧哈哈哈，现在就是一个丑东西，也还没有搞一个域名来绑定，晚点弄一个来van","link":"/2018/05/28/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%91%A8%E7%BB%93%EF%BC%88%E8%87%B35-28%EF%BC%89/"},{"title":"第二次周结（至6-10）","text":"考试月了，主要是在准备考试，学课程的东西以及准备六级 博客 给博客换了一个主题，以及加了一个音乐播放器，以前用网易云的时候就发现有个功能“生成外链播放器” 本来是想放幻界战线的hello world的，挺喜欢这首歌，竟然锁区不给。。虽然可以破解这个版权保护，还是算了，放了个纪念龙族绘梨衣的bgm 还改了一些杂七杂八的，干货分享有个steam便利店，可以优惠价买steam的游戏或者低价买随机cdk，贼好的东西，需要的可以看看 javascript 因为忙着课程和四六级的，没有学太多，就把上次留下的小尾巴看了看，几种设计模式和几种继承(后续准备开一个单章处理这个问题) 课程杂谈？（只是想吐槽下罢了） 要六级啦，就试听了一次听力，难得一批，更别说单词还没刷完，周六的模拟考竟然是因为学委打王者入神忘记发通知？？？(excuse me?) 高数还行吧，电工依旧要命，这周还没能把时间放在电工上 离散的anyview也是要命的，就拿今晚的事，做这一道题，递归运算足足花了我一小时。。C语言和算法退化了啊 附上做的答案（要不是同学请教，且网上没有这道题的答案，哪用这么受罪TAT） 啊~~还是刷刷单词去了","link":"/2018/06/10/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%91%A8%E7%BB%93%EF%BC%88%E8%87%B36-10%EF%BC%89/"},{"title":"练手项目开始","text":"设计稿交给我们了，前半天让Zyn给我指导下做页面的事项，后半天想一下affair 前端方面get到的小知识今天从中午开始就一直在做一个页面，因为是第一次做网页(除教程外的第一个)，遇到了很多很多的问题，我想做熟练了写起代码来应该就会得心应手很多吧。 get到一些很基础的 写页面的时候用到的技巧（至少目前我是这样被教育的） *{ margin: 0; padding: 0;} 背景填充用background-size: cover; 想要实现同行排列几个块的时候对父级div设置font-size:0px对小块div用display: inline-block一般还对小块div设置margin:0px和width:占比%； float浮动和clear 尽量不要乱用，惨痛 新学到的 cursor: pointer;鼠标指针样式 后台方面 今天设计正式提出了接下来的Affair项目功能需求，涉及的东西挺多 接下来要做的东西中“较为可行”的 如何授权微信登录 实现点赞 评论（后面两个还行，第一个看下教学吧） 发布任务 最难搞的还是那些逻辑，毕竟是以前没有做过的things，真实情况也的确是难度很大，开发不完应该是板上钉钉，但是也会拼尽全力去实现的！！！","link":"/2018/07/23/%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%A7%8B/"},{"title":"继承、执行上下文、this浅理解","text":"早上瀚程扔了一个王福朋的博客，里面讲了很多有关JS CSS的东西。早上听讲了原型链，this，执行上下文等，回头也结合王福朋的博客看了一点。 对象都是通过函数来创建的，但是函数又是一种对象（万物皆对象） 每一个函数都有一个prototype属性，这个属性的值是一个对象（属性集合），默认的只有一个构造器函数constructor，指向函数本身。 每个对象都有一个隐藏的属性——“proto”，这个属性引用了创建这个对象的函数的prototype。即：fn.proto === Fn.prototype 下面是一个经典的例子123456789function Fn() { } Fn.prototype.name = '王福朋'; Fn.prototype.getYear = function () { return 1988; }; var fn = new Fn(); console.log(fn.name); console.log(fn.getYear()); 继承 访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。 由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。 执行上下文通俗说法在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。 this的取值在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了分为四种情况，震惊，这么详细 1、 构造函数中this指向new出来的对象2、 函数作为对象的一个属性，并且被调用,this指向这个对象，如果作为属性但是不被调用，还是指向window3、 函数用call或者apply调用，this的值取传入的参数（对象）的值4、 全局下this指向window，普通函数调用的时候也是指向window","link":"/2018/07/17/%E7%BB%A7%E6%89%BF%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81this/"},{"title":"网络性能测试的主要概念","text":"并发量、吞吐量、RT、TPS、QPS 还有其他一些少见的概念的介绍。 重要常见概念并发量系统同时能处理的请求数量,反应了系统的负载能力 吞吐量单位时间内系统能处理的请求数量，体现系统处理请求的能力，这是目前最常用的性能测试指标 响应时间RT(Response-time)响应时间是一个系统最重要的指标之一，它的数值大小直接反应了系统的快慢。响应时间是指执行一个请求从开始到最后收到响应数据所花费的总体时间,即从客户端发起请求到收到服务器响应结果的时间 TPS(Transactions Per Second)事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数 QPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中例：访问一个页面会请求服务器3次，一次放，产生一个“T”，产生3个“Q” QPS(Queries Per Second)每秒查询率，是一台服务器每秒能够相应的查询次数，即1秒内完成的请求数量，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准 QPS计算公式QPS = 并发量 / 平均响应时间 = 某段时间内PV/这段时间秒数 单线程QPS=1000ms/RT 多线程QPS= n * （1000ms/RT） 按照公式可见QPS随着线程的增加而线性增长，但是现实肯定不是线性增长的,毕竟服务器资源有限 QPS与RT关系1.对于大部分web系统，响应时间一般由CPU执行时间，线程等待时间（IO等待，sleep, wait）时间组成。QPS和RT成反比关系 2.在实际的测试环境中，QPS和RT并不是非常直接的反比关系 最佳线程数量刚好消耗完服务器的瓶颈资源的临界线程数公式：最佳线程数量=（（线程等待时间+线程cpu时间）/线程cpu时间）* cpu数量 特性：1.在达到最佳线程数的时候，线程数量继续递增，则QPS不变，而响应时间变长，持续递增线程数量，则QPS开始下降2.每个系统都有其最佳线程数量，但是不同状态下，最佳线程数量是会变化的3.瓶颈资源可以是CPU,可以是内存，可以是锁资源，IO资源 其他概念bps比特率，路单位，表示bit(比特)/second(秒)。在计算机网络或者是网络运营商中，一般，宽带速率的单位用bps(或b/s)表示；bps表示比特每秒即表示每秒钟传输多少位信息。 pps包转发率单位，表示包/秒，交换机每秒可以转发多少百万个数据包（Mpps），即交换机能同时转发的数据包的数量，表示交换机的交换能力。 Bps用户在网上下载时显示的速率单位，表示Byte(字节)/second(秒)","link":"/2021/01/08/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5/"},{"title":"蒲公英俱乐部开张啦","text":"蒲公英俱乐部开张第一天安装了putty,phpstudy在阿里云够买了一个学生版服务器学会了git里面多人合作常用流程还有就是，这个假的奥克斯，好热~~~ git虽然以前是在廖雪峰的官网学过git的各种命令，但是时隔有点久也是生疏了，最主要的还是学到了 多人协作常用的命令流程：一个人开仓库，邀请其他伙伴作为开发者参与，其他人clone后再checkout自己的分支，多人协作一般是在自己的分支干活，需要提交的时候是先切换回master,pull一下看看远程库有没有更新信息，然后将自己的分支与master合并(merge)，合并完再push，如果有冲突处理完再push上去。 阿里云9.9特惠学生套餐有了自己的云服务器和公网IP47.106.21.195 putty(lnmp)screen -S xxxx创建窗口(我创建的第一个窗口命名lnmp)screen -ls 查看有哪个窗口screen -r xxxx进入指定窗口 lnmp一键安装搞定了 然后就可以访问那串IP了 默认是读取index(像豪哥自己那个博客就是放在自己的公网IP下的) 进去index的路径/home wwwroot/ fault/ mv 移动文件或者改名字 如果是要修改名字的话 mv+原名+新名 vim 创建编辑模式 ，按i进入编辑模式，否则是观察模式，按esc回到观察模式，打一个冒号然后:wq 退出并保存","link":"/2018/07/12/%E8%92%B2%E5%85%AC%E8%8B%B1%E4%BF%B1%E4%B9%90%E9%83%A8%E5%BC%80%E5%BC%A0%E5%95%A6/"},{"title":"近期一句话总结","text":"·git checkout practice：新世界是暑期前做的，开学后又进行了细节的修改，因为是第一次做页面，学到的东西还是非常多。之后做了一个打字机小游戏和一个简单的主要利用定时器和工厂实现的动画。·git checkout DOM:日常被各种事情卡住，只有在文学课上才是最专心的。 ·git checkout other：其他一些东西，如每天的网课和英语课。 ·git checkout node：node还是继续之前那些视频资源，群里偶尔也有新暂时没有精力 ·git checkout affair：弄来了两个“优秀的”源码来学习，看看能不能学到啥把阿肥魔改，真的是一堆不成熟的想法+不成熟的技法导致很多问题，9月22日前端们终于突然想起要继续对接了，所以中秋假期又双叒叕还是自己忙前忙后。","link":"/2018/09/23/%E8%BF%91%E6%9C%9F%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93/"},{"title":"预请求","text":"预请求的应用场景，原理，出现的前置条件。 应用场景js发送一次ajax请求时,在浏览器那边却会查询到两次请求,第一次的Request Method参数是OPTIONS,还有一次就是我们真正的请求,比如get或是post请求方式 原理这是浏览器对复杂跨域请求的一种处理方式,在真正发送请求之前,会先进行一次预请求,就是我们刚刚说到的参数为OPTIONS的第一次请求,他的作用是用于试探服务器响应是否正确,即是否能接受真正的请求,如果在options请求之后获取到的响应是拒绝性质的,例如500等http状态,那么它就会停止第二次的真正请求的访问 出现预请求的情况致说明一下,有三种方式会导致这种现象: 请求的方法不是GET/HEAD/POST 请求虽然是POST，但是Content-Type的类型除了下面三种application/x-www-form-urlencoded, multipart/form-data, 或text/plain 请求设置了自定义的header字段 XMLHttpRequestUpload 对象注册了任何事件监听器 请求中使用了ReadableStream对象","link":"/2019/09/16/%E9%A2%84%E8%AF%B7%E6%B1%82/"},{"title":"JavaScript代码规范","text":"规范你的JavaScript代码，仅列举一些个人觉得对日常coding中有帮助的点。推荐使用（非必须）。 数组 使用 Array.from 代替展开符 ... 映射迭代器，因为它避免了创建一个中间数组。12345// badconst baz = [...foo].map(bar);// goodconst baz = Array.from(foo, bar); 在访问和使用对象的多个属性时使用对象解构。 123456789101112131415161718// badfunction getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; return `${firstName} ${lastName}`;}// goodfunction getFullName(user) { const { firstName, lastName } = user; return `${firstName} ${lastName}`;}// bestfunction getFullName({ firstName, lastName }) { return `${firstName} ${lastName}`;} 使用数组展开符 … 来拷贝数组； 将一个可迭代对象转换成一个数组，用展开符 … 代替 Array.from12345// goodconst nodes = Array.from(foo);// bestconst nodes = [...foo]; 将一个类数组对象转换成一个数组，用Array.from1234567const arrLike = { 0: 'foo', 1: 'bar', 2: 'baz', length: 3 };// badconst arr = Array.prototype.slice.call(arrLike);// goodconst arr = Array.from(arrLike); 使用 rest 语法 … 代替 arguments1234567891011//... 明确了你想要拉取什么参数。 而且, rest 参数是一个真正的数组，而不仅仅是类数组的 arguments// badfunction concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join('');}// goodfunction concatenateAll(...args) { return args.join('');} 函数","link":"/2021/08/16/JavaScript%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"},{"title":"浏览器缓存","text":"浏览器缓存是一个很重要的知识点，下面从缓存的优先级、作用、强缓存与协商缓存的特性这几个角度介绍，后续考虑补充说明。 缓存的优先级 缓存的作用： 减少延迟(页面打开的速度)。 降低服务器负载(先取缓存，无缓存在请求服务器，有效降低服务器的负担)。 保证稳定性(有个笑话是手机抢购时为了保证服务器的稳定性，在前端写个随机数限制百分之二十的人发送数据到后台，这也侧面说明了缓存对于稳定性的作用)。 Expires指定服务器返回的文件有效期，是一个指定日期(截止日期)，但是会受到本机系统时间影响，比如修改电脑时间到2111年，那么这个缓存就一定会过期了 Last-Modified指服务器文件的最后修改时间，浏览器会带上If-Modified-Since字段(注意在请求头中的字段是这个，响应头中的字段才是Last-Modified)向服务器发送请求，与服务器文件修改时间Last-Modified做对比，如果时间不同，则获取数据返回200，否则返回304后调用浏览器本地硬盘的缓存。 304状态码，简单的表达就是：服务端已经执行了GET，但文件未变化。 这种方式也有问题，如果服务端文件频繁修改保存，那么Last-Modified就会频繁更改，每次都从服务端获取，这也就有了http1.1的ETag出现 Cache-Control指文件缓存的有效期(持续时间)。 max-age:单位是s，设置文件最大缓存时间，用得最多。 public:缓存可以被多用户共享，例如360浏览器可以登录不同账号，电脑系统可以切换不同账号。 private:仅单用户私有，不被多用户共享。 no-cache:不会被缓存。 no-store:不允许被存储。 ETag http1.1推出，对应一个版本号，由服务端随机生成的，浏览器会带上If-None-Match字段向服务器发送请求，与服务器文件修改版本ETag做对比，如果版本号不同，则获取数据返回200，否则返回304后调用浏览器本地硬盘的缓存，这种方式比Last-Modified靠谱。 其他知识点 如果浏览器只支持http1.0，那么浏览器只会携带Last-Modified发送给后台 如果服务器只支持http1.0，那么服务器会以Last-Modified为标准。 如果浏览器支持http1.1，那么浏览器会携带Cache-Control+Last-Modified+ETag发送给后台 如果服务器支持http1.1，那么服务器会以Cache-Control+ETag为标准。","link":"/2019/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"ECS","slug":"ECS","link":"/tags/ECS/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"杂谈","slug":"杂谈","link":"/tags/%E6%9D%82%E8%B0%88/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"字符编码","slug":"字符编码","link":"/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"},{"name":"计网","slug":"计网","link":"/tags/%E8%AE%A1%E7%BD%91/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"模块化","slug":"模块化","link":"/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Express","slug":"Express","link":"/tags/Express/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Koa","slug":"Koa","link":"/tags/Koa/"},{"name":"Mongo","slug":"Mongo","link":"/tags/Mongo/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Js","slug":"Js","link":"/tags/Js/"},{"name":"Token","slug":"Token","link":"/tags/Token/"},{"name":"Ts","slug":"Ts","link":"/tags/Ts/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"Http","slug":"Http","link":"/tags/Http/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"规范","slug":"规范","link":"/categories/%E8%A7%84%E8%8C%83/"},{"name":"JavaScript","slug":"规范/JavaScript","link":"/categories/%E8%A7%84%E8%8C%83/JavaScript/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"初行者","slug":"笔记/初行者","link":"/categories/%E7%AC%94%E8%AE%B0/%E5%88%9D%E8%A1%8C%E8%80%85/"},{"name":"探索者","slug":"笔记/探索者","link":"/categories/%E7%AC%94%E8%AE%B0/%E6%8E%A2%E7%B4%A2%E8%80%85/"},{"name":"浏览器","slug":"前端/浏览器","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"计算机","slug":"计算机","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"vue","slug":"前端/vue","link":"/categories/%E5%89%8D%E7%AB%AF/vue/"},{"name":"小程序","slug":"前端/小程序","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"HTML","slug":"前端/HTML","link":"/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"ES6","slug":"前端/ES6","link":"/categories/%E5%89%8D%E7%AB%AF/ES6/"},{"name":"后端","slug":"后端","link":"/categories/%E5%90%8E%E7%AB%AF/"},{"name":"db","slug":"后端/db","link":"/categories/%E5%90%8E%E7%AB%AF/db/"},{"name":"Node","slug":"后端/Node","link":"/categories/%E5%90%8E%E7%AB%AF/Node/"},{"name":"Linux","slug":"后端/Linux","link":"/categories/%E5%90%8E%E7%AB%AF/Linux/"},{"name":"基础","slug":"前端/基础","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"},{"name":"Ts","slug":"前端/Ts","link":"/categories/%E5%89%8D%E7%AB%AF/Ts/"},{"name":"Webpack","slug":"前端/Webpack","link":"/categories/%E5%89%8D%E7%AB%AF/Webpack/"}]}