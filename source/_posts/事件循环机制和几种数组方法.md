---
title: 事件循环机制和几种数组方法
date: 2018-07-16 00:00:00
tags: [eventloop]
categories: 
- 笔记
- 探索者
cover: https://picsum.photos/seed/20180716/500/300
thumbnail: https://picsum.photos/seed/20180716/500/300
toc: true
---

<font face="STCAIYUN" color=gray size=6>Everything runs in parallel except your code!</font>



### 事件循环（以及异步，回调）
js 事件轮询机制
>在js中同步和异步的任务会分别进入不同的执行场所，同步任务进入主线程异步的进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的Event Loop(事件循环)。
![Alt text](2018041120124254.png)

>但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。![Alt text](20180411202638415.png)

菠萝说的 
宏任务一般有：script，setTimeout，setInterval。

微任务：Promise，process.nextTick。


### 数组操作几种方法(codewar)
>今天做的这道题让我回忆，以及get到了一些或旧或新的方法，这些方法都是挺有用的
#### filter()过滤
filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。
>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：
```js
var arr = [1, 2, 4, 5, 6, 9, 10, 15];
2 var r = arr.filter(function (x) {
3     return x % 2 !== 0;
4 });
5 r; // [1, 5, 9, 15]
```
#### split()分隔
>分割字符串的方法
注意这两个
split("") 每个元素分隔
split(" ")以空格为分隔符分隔
#### 几种遍历方法
>回顾了一下js数组遍历的几种方法
1、 普通for循环,最简单的一种，也是使用频率最高的一种，瀚程如是说，的确是最熟悉性能也是挺高

```
for(j = 0; j < arr.length; j++) {
 } 
```
2、 

```
arr.forEach(function(e){  
});
```
3、

```
Array.prototype.forEach.call(arr,function(el){    
});
```
4、

    for(i in或者of  arr){
    }
5、 map遍历

    arr.map(funtion(n){
    })


### DNS解析
记录类型A 表明主机记录指向唯一的IP
记录类型CNAME 一个域名指向另一个域名

买了一个新的域名尝试了将其指向原有的博客域名，一顿操作终于好了
缓存真是个奇怪的东西，明明就是ping一样的地址，上一刻和下一刻效果不一样
### 添加虚拟主机的常用命令
lnmp vhost add
lnmp vhost list
cd /home wwwroot/ 
lnmp list
cd 进去 找到index.html，vim模式编辑

### express
>Post请求体
+ 常用媒体类型是application/x-www-form-urlencoded
+ 如果需要上传文件 multipart/form-data
+ 如果是AJAX请求 application/json

## 最后附上一道题，有关异步的

```js
setTimeout(function(){
		    console.log('1')
		});
 
		new Promise(function(resolve){
		    console.log('2');
		}).then(function(){
		    console.log('3')
		});
 
		console.log('4');
```

>这段代码的运行顺序 2，4，3，1
原因就是 然后回到开头的代码。因为settimeout是宏任务，虽然先执行的他，但是他被放到了宏任务的eventqueue里面，然后代码继续往下检查看有没有微任务，检测到Promise的then函数把他放入了微任务序列。等到主线进程的所有代码执行结束后。先从微任务queue里拿回掉函数，然后微任务queue空了后再从宏任务的queue拿函数。
