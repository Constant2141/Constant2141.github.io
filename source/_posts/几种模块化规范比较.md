---
title: 几种模块化规范比较
date: 2019-07-19 10:04:48
tags: [模块化]
categories: 
- 笔记
- 探索者
cover: https://picsum.photos/seed/20190719/500/300
thumbnail: https://picsum.photos/seed/20190719/500/300
toc: true
---

### commonjs

commonjs是node应用的模块规范，每个文件都是一个模块

每个模块内部，module代表当前模块，也就是文件本身

module.exports属性是对外的接口，加载一个模块其实就是加载module.exports

每个模块都有一个exports变量，指向module.exports。相当于var exports = module.exports，但是要用直接用exports的话，只能在成员上添加，例如exports.add = function(){}，不能直接赋值，会切断和module.exports的连接，所以尽量不要直接用exports

require加载模块，返回的是引入模块的exports对象

### 模块加载规则
根据require字符串参数的不同
1. /开头，绝对路径
2. ./ 相对路径
3. 一个模块的名字，加载的是核心模块，位于各级目录下的node_modules，寻找的路径是从同级目录下开始往上找
4. 如果是路径，例如`require('aaa/bbb/ccc')`先找aaa位置，再找后面的
5. 如果都没有找到，node会给文件名添加.js,.json,.node后缀，再去搜索，分别以js脚本解析，json文本解析，二进制文件解析

第一次加载该模块，node会缓存该模块。再次加载，直接从缓存中取出该模块的module.exports属性。
缓存是保存在`require.cache`
删除缓存是用`delete require.cache[moduleName];`基本不会用到这个的

模块输出的变量就跟原模块没有关系了，原来的模块变化，不会影响到输出的变量


### AMD与commonjs的区别
AMD规范则异步加载模块，允许指定回调函数

CommonJS规范加载模块是同步的，只有加载完成，才能执行后面的操作。

```js
//commonjs写法
var clock = require('clock');
clock.start();


//AMD写法
require(['clock'],function(clock){
  clock.start();
});
```

### AMD和CMD的区别

```js
//CMD的写法
define(function(require, exports, module) {
   var clock = require('clock');
   clock.start();
});
```
AMD和CMD最大的区别是依赖模块的执行时机不同，而不是加载时机或者加载方式不同，其实二者皆为异步加载模块

AMD依赖前置，js可以方便知道依赖模块是什么，立即加载；而CMD就近依赖，需要把模块变为字符串解析一遍才知道依赖了那些模块，但是解析模块用的时间短到可以忽略

### ES6的模块化

export后面跟要暴露的对象，export default是缺省，一个模块只能有一个default
```js
import * as name from "xxx"  //通配符引入所有export的变量， as作用是重命名
import {a,b,c} from "xxx" //引入指定的变量
import x from ""//没有使用{}的，这样写会引入export default
import "./1.jpg"//模块也可以是图片，js文件，这样直接引入模块的代码，不引入内部成员
let promise = import("xxx") //也支持异步引入，一定要绝对路径，在编译的时候会生成异步的模块，前面带有数字那些文件就是
```

